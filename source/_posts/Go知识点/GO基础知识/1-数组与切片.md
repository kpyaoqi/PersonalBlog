---
title: 1-数组与切片

date: 2021-12-12	

categories: GO基础知识	

tags: [Go知识点,GO基础知识]
---	

# 数组和切片的异同

**slice 的底层数据是数组，slice 是对数组的封装**，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

**数组是定长的，长度定义好之后，不能再更改，而切片则非常灵活，它可以动态地扩容。**切片的类型和长度无关。

> 数组：因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。

**数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。**

```golang
// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```

> 注意：底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。

```go
func main() {
	slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := slice[2:5]
	s2 := s1[2:6:7]  		//len=4,cap=5
	s2 = append(s2, 100)	//s2容量够，直接追加，会直接影响到s1和slice
	s2 = append(s2, 200)	//s2容量已满，进行扩容，底层数组指针更改，不影响
	s1[2] = 20				//影响slice
	fmt.Println(s1)
	fmt.Println(s2)
	fmt.Println(slice)
}

//结果：
[2 3 20]
[4 5 6 7 100 200]
[0 1 2 3 20 5 6 7 100 9]
```

# 切片容量的增长

**使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素**。但是**底层数组的长度是固定的**，**如果索引** `len-1` 所指向的元素**已经是底层数组的最后一个元素，就没法再添加了。**

这时，**slice 会迁移到新的内存位置，新底层数组的长度也会增加，**这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 `slice` 的容量是留了一定的 `buffer` 的。否则，每次添加元素的时候，都会发生迁移，成本太高。

在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的：

>当原 slice 容量小于 `1024` 的时候，新 slice 容量变成原来的 `2` 倍；原 slice 容量超过 `1024`，新 slice 容量变成原来的`1.25`倍。

在1.18版本更新之后，slice的扩容策略变为了：

> 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4

向一个nil的slice添加元素会发生什么？为什么？

其实 `nil slice` 或者 `empty slice` 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 `mallocgc` 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的`nil slice` 或 `empty slice`，然后摇身一变，成为“真正”的 `slice` 了。

# 切片作为函数参数

不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据

> 值得注意的是，Go 语言的函数参数传递，只有值传递，没有引用传递。