---
title: 02-数据

date: 2022-06-15	

categories: Solidity0.8.17	

tags: [区块链,Solidity0.8.17]
---	

# 数据与变量

##  隐式转换

如果上面 `uint256 u = 123;` 改为 `uint256 u = "Hello";`，将会收到错误 `Type literal_string "Hello" is not implicitly convertible to expected type uint256.`，因为这两种类型不能隐式转换的；

如果上面 `uint256 u = 123;` 改为 `uint256 u = uint8(123);`，就不会有问题，因为`uint8`类型可以隐式转换为`uint256`类型。后面介绍类型转换的时候会详细的介绍。

# 两种类型的数据

Solidity 按照数据类型可以分为**值类型**和**引用类型**。

- 值类型: 值类型传值时会将值拷贝一份，传递的是值本身，对其修改时并不会对原来值有影响。
  - 始终按值来传递，当被用作函数参数或者用在赋值语句中时，总会进行值拷贝。
  - 值类型里有两个比较特殊的类型是函数和地址（包括合约），会分为单独的部分介绍。
- 引用类型: 引用类型进行传递时，传递的是其指针，而引用类型进行传递时**可以为值传递**，**也可以为引用传递**。

# 值类型

1. Boolean
2. Integer:uint/int
3. 定长字节数组(固定大小字节数组):bytes1-bytes32
4. Enum:枚举
5. 地址（Address）
6. 合约类型
7. 函数（Function Types）

## 3.1 Boolean 布尔类型

布尔型使用 `bool`表示，该类型只有两个值，分别是 `true`/`false`。

布尔值除了赋值得到外，还可以通过**运算符**的计算结果得到。

支持的运算符:`!`逻辑非，`==`等于，`!=` 不等于,`&&`逻辑与 ,`||`逻辑或

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo2 {
    bool public a = false;
    bool public b = !a; // 仅用于布尔值
    bool public c = a == b;
    bool public d = a != b;
    bool public e = a && b;
    bool public f = a || b;
}
```

运算符 `||` 和 `&&` 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 `f(x) || g(y)` 中， 如果 `f(x)` 的值为 true ，那么 `g(y)` 就不会被执行，

### 3.1.1 使用短路规则节省 gas

借助短路规则，可以让合约少执行一些逻辑。

- `||` 如果第一个表达式是`true`，则第二个表达式不再执行。（因为两个表达式有一个为 true，结果就为 true，不需要计算第二个表达式就知道结果了）
- `&&` 如果第一个表达式是`false`，则第二个表达式不再执行。（两个表达式必须都为 true，结果才能 true，如果第一个为 false，不需要计算第二个表达式就知道结果了）

## 3.2 Integer 整数类型

整数类型分为有符号整型，用 int 标示；和无符号整型，用 uint 标示；

- int 是有符号整型，支持 int8 到 int256。
- uint 是无符号整型，支持从 uint8 到 uint256。
- `uint` 和 `int` 分别是 `uint256` 和 `int256` 的别名。

### 3.2.1 属性

对于整型 T 有下面的全局属性可访问：

> 获取整型 T 的最小值:type(T).min
> 获取整型 T 的最大值:type(T).max

### 3.2.2 uint 类型

uint 无符号整数，只能表示非负数；`包括数字0`；其中 uint256 与 uint 相同，推荐使用 uint256；支持 int8 到 int256，后面的数字是 8 的倍数。

- `uint8`: 最小值是 0，最大值是 `2**8-1`
- `uint256`:最小值是 0，最大值是 `2**256-1`
- 可以使用 `type(uint8).max` 获取该类型的最大值
- 可以使用 `type(uint8).min` 获取该类型的最小值

### 3.2.3 int 类型

int 是有符号整数，其中 int256 与 int 相同，推荐使用 int256； 8 位到 256 位的带符号整型数。8 的倍数。

- `int8`: 最小值是 `-128`，最大值是 `127`
- `int256`: 最小值是 `-(2**256/2)`，最大值是 `(2**256/2)-1`
- 可以使用 `type(int8).max` 获取该类型的最大值
- 可以使用 `type(int8).min` 获取该类型的最小值。

计算中最小一级的信息单位是 byte 和 bit: **其中字节(Byte)为最小存储容量单位**，**位(bit)是最小储存信息的单位,也被称为最小的数据传输单位**；一个位就代表一个 0 或 1（即二进制）；每 8 个 bit(简写为 b）组成一个字节 Byte（简写为 B）；所以 `uint256` 和 `bytes32` 可以转换

- `bytes1 对应 uint8`
- `bytes2 对应 uint16`
- …
- `bytes32 对应 uint256`

### 3.2.4 checked 模式

⚠️: 在 Solidity 之前的版本中，当对无限制整数执行算术运算，其结果超出结果类型的范围，这是就发生了上溢出或下溢出。在 Solidity 0.8.0 之前，算术运算总是会在发生溢出的情况下进行“截断”，而不是抛出异常。这就会导致一些麻烦的事情，可能导致未知的错误，所以我们不得不靠引入额外检查库来解决这个问题（最常见的如 OpenZepplin 的 SafeMath）

而从 `Solidity 0.8.0` 开始，所有的算术运算默认就会进行溢出检查，额外引入库将不再必要。0.8.0 开始，算术运算有两种计算模式：一种是`checked`（检查）模式，另一种是 `unchecked`（不检查）模式。

默认情况下，算术运算在 `checked` 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。

### 3.2.5 unchecked 非检查模式

如果依然想要之前“截断”的效果，而不是抛出异常错误，那么可以使用 `unchecked{}` 代码块：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    uint256 public a = type(uint256).max;
    uint8 public b = 1;

    function f1() public view returns (uint256) {
        // 减法溢出会返回“截断”的结果
        unchecked {
            return a + b;
        }
    }

    function f2() public view returns (uint256) {
        unchecked {
            return a + 2;
        }
    }

    function g() public view returns (uint256) {
        // 溢出会抛出异常
        return a + b;
    }
}
```

调用 `g()` 会触发失败异常， 调用 `f1()/f2()` 分别是截断效果,

⚠️: `unchecked` 代码块可以在代码块中的任何位置使用，但不可以替代整个函数代码块，同样不可以嵌套。切此设置仅影响语法上位于 `unchecked` 块内的语句。 在块中调用的函数不会此影响。

⚠️: 为避免歧义，不能在 unchecked 块中使用 `_;`, 该表示方法仅用于函数修改器。

>  触发溢出检查的运算符:++`, `--`, `+`, `减 -`, `负 -`, `*`, `/`, `%`, `**, +=`,`-=`, `*=`, `/=`, `%=

>  除 `0`（或`除 0取模`）的异常是不能被 `unchecked` 忽略的。会发生 `Panic` 错误。

>  位运算不会执行上溢或下溢检查

>  -int 值需要注意:因为负数的范围比正整数的范围大 1。



## 3.3 Integer 整数字面常量

### 3.3.1 常量中用`_`增加可读性

为了提高可读性可以在数字之间加上下划线。 例如，十进制 `123_000`，十六进制 `0x2eff_abde`，科学十进制表示 `1_2e12` 都是有效的。

需要注意以下几点：

- 下划线仅允许在两位数之间，并且不允许下划线连续出现。
- 添加到数字文字中下划线没有额外的语义，仅仅只是为了可读性.
- 下划线会被编译器忽略。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo{
    uint public count1 = 123_456_789; // 23503 gas
    uint public count2 = 123_456_789; // 23493 gas
    uint public count3 = 123456789; // 23537 gas
    int public count4 = -123456789; // 23559 gas
    int public count5 = -123_456_789; // 23471 gas
}
```

通过测试发现，带有`_`数字的变量，读取时候花费 gas 更少

### 3.3.2 字面常量支持任意精度

数值字面常量表达式本身支持任意精度，直到被转换成了非常量类型（例如，在常量变量表达式之外有运算，或发生了显示转换）。 这意味着在数值常量表达式中, 计算不会溢出而除法也不会截断。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint8 public a = (2**800 + 1) - 2**800;
    uint8 public b = 0.5 * 8;
}
```

`(2**800 + 1) - 2**800` 的结果是字面常量 1 （属于 uint8 类型），尽管计算的中间结果已经超过了 以太坊虚拟机的机器字长度。 此外， `0.5 * 8` 的结果是整型 `4` （尽管有非整型参与了计算）。

⚠️: 数 值字面常量表达式只要在非字面常量表达式中使用就会转换成非字面常量类型。 在下面的例子中，尽管我们知道 b 的值是一个整数，但 `2.5 + a` 这部分表达式并不进行类型检查，因此编译不能通过。

```
uint128 a = 1;
uint128 b = 2.5 + a + 0.5;
```

### 3.3.3 除法截断

注意除法截断: 在智能合约中，在 字面常量 会保留精度（保留小数位）。

整数的除法会被截断（例如：`1/4` 结果为 0）,但是使用字面量的方式不会被截断

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract IntegerTest {
    function test1() public pure returns (uint256, uint256) {
        uint256 a = 1;
        uint256 b = 4;
        uint256 c1 = (1 / 4) * 4; // 1 => 未截断
        uint256 c2 = (a / b) * b; // 0 => 截断
        return (c1, c2);
    }
}
```

注释: 表达式 `type(int).min / (-1)` 是仅有的整除会发生向上溢出的情况。 在算术检查模式下，这会触发一个失败异常，在截断模式下，表达式的值将是 `type(int).min` 。

### 3.3.4 优先使用较小类型计算

虽然大多数运算符在字面常量运算时都会产生一个字面常量表达式，但有一些运算符并不遵循这种模式：

- 三元运算符 `(... ? ... : ...)`,
- 数组下标访问 (`<array>[<index>]`).

你可能认为像`255 + (true ? 1 : 0)` 或 `255 + [1, 2, 3][0]` 这样的表达式等同于直接使用 256 字面常量。 但事实上，它们是在 `uint8` 类型中计算的，会溢出。

## 3.4 Fixed 定长浮点型

Solidity 还没有完全支持定长浮点型，可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。。

可以通过用户定义的值类型的 wrap / unwrap 来模拟出来，后面介绍用户自定义类型时候会介绍。

`fixed / ufixed`：表示各种大小的有符号和无符号的定长浮点型。 在关键字 `ufixedMxN` 和 `fixedMxN` 中，`M` 表示该类型占用的位数，`N` 表示可用的小数位数。 `M` 必须能整除 8，即 8 到 256 位。 `N` 则可以是从 0 到 80 之间的任意数。

## 3.5 BytesN 定长字节数组

定义方式 `bytesN`，其中 N 可取 `1~32` 中的任意整数;

bytes1 代表只能存储一个字节。

⚠ 注意：一旦声明，其内部的字节长度不可修改，内部字节不可修改。

`bytesN`: 是定长的字节数组，是值类型

`bytes`: 是变长字节数组，是引用类型。

### 3.5.1 属性

- ```solidity
  length
  ```

  （只读）返回字节个数，可以通过索引读取对应索引的字节。

- 索引访问:

  ```solidity
  bytesN[index]
  ```

  - index 取值范围`[0, N]`，其中 N 表示长度。

- 如果 `x` 是 `bytesI` 类型，那么 `x[k]` （其中 0 <= k < I）返回第 k 个字节（只读）。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // 固定长度的字节数组
    bytes1 public a1 = 0x61;
    bytes2 public a2 = 0x6100;

    // length
    uint256 public n1 = a1.length;
    uint256 public n2 = a2.length;

    // 索引
    function getIndex(uint8 index_) public view returns(bytes1){
        return a2[index_];
    }

    // 不修可以修改,编译会报错
    //function setIndex(uint8 index_,bytes1 value_) public view{
    //     a2[index_] = value_;
    //}
}
```

## 3.6 字符串字面常量及类型

字符串字面常量只能包含可打印的 ASCII 字符，这意味着他是介于 0x20 和 0x7E 之间的字符。

字符串字面常量是指由双引号或单引号引起来的字符串（ `"foo"` 或者 `'bar'`）;

### 3.6.1 字符串字面量

转换: 和整数字面常量一样，字符串字面常量的类型也可以发生改变，它们可以隐式地转换成`bytes1`，……， `bytes32`，如果合适的话，还可以转换成 `bytes` 以及 `string`。

比如 `bytes1 public a8 = "a";` 和 `bytes2 public b2 = "a";`。字符串字面常量在赋值给 `bytesN` 时被解释为**原始的字节形式**。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    bytes1 public b1 = "a";
    string public b2 = "a";
}
```

### 3.6.2 转义字符

但是我们写特殊字符串时候遇到一个问题，比如我想输出一个 `fo"o`和`fo'o` 的字符串就很难弄，因为莫认为`"`和`'` 是字符串的结尾。如果想要输出这种特殊的字符串，就需要转义字符了。

此外，字符串字面常量支持下面的转义字符：

- `\'` (单引号)
- `\"` (双引号)
- `\\` (反斜杠)
- `\<newline>` (转义实际换行)
- `\b` (退格)
- `\f` (换页)
- `\n` (换行符)
- `\r` (回车)
- `\t` (标签 tab)
- `\v` (垂直标签)
- `\xNN` (十六进制转义，见下文)
- `\uNNNN` (unicode 转义，见下文)

`\xNN` 表示一个 16 进制值，最终转换成合适的字节，而 `\uNNNN` 表示 Unicode 编码值，最终会转换为 UTF-8 的序列。

问答题:下面字符串长度为多少字节？

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string public a1 = "\n\"'\\abc\def";
    bytes32 public a2 = "\n\"'\\abc\def";
}
```

字符串长度为十个字节，它以换行符开头，后跟双引号，单引号，反斜杠字符，以及（没有分隔符）字符序列 `"'\abcdef` 。

### 3.6.3 用空格分开的字符串

用空格分开的 `"foo" "bar"` 等效于 `"foobar"`,

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string public a = "a" "b";//ab
}
```

## 3.7 Unicode 字面常量

常规字符串文字只能包含 ASCII，而 Unicode 文字（以关键字 unicode 为前缀）可以包含任何有效的 UTF-8 序列。 它们还支持与转义序列完全相同的字符作为常规字符串文字。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string  public a = unicode"同志们好";
}
```

## 3.8 十六进制字面常量

十六进制字面常量以关键字 `hex` 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，`hex"001122FF"` ）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。

### 3.8.1 基本用法

它们的内容必须是十六进制数字，可以选择使用单个下划线作为字节边界分隔符。 **字面常量的值将是十六进制序列的二进制表示形式**。

用空格分隔的多个十六进制字面常量被合并为一个字面常量： `hex"61" hex"61"` 等同于 `hex"6161"`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    bytes1 public a3 = 0x61;
    bytes1 public a4 = hex"61";
    bytes2 public a = hex"61" hex"61";
}
```

## 3.9 Enum:枚举

`enum` 是一种用户自定义类型，用于表示多种状态，枚举可用来创建由一定数量的“常量值”构成的自定义类型。主要作用是用于限制某个事务的有限选择。比如将咖啡的容量大小限制为：大、中、小，这将确保任何人不能购买其他容量的咖啡，只能在这里选择。

枚举默认值是第一个成员，所以**枚举类型至少需要一个成员，枚举不能多于 256 个成员**。枚举默认的类型为 `uint8`，当枚举数足够多时，它会自动变成 `uint16`..等变大。可以通过 remix 部署后，函数的输入值内查看类型 `uint8` / `uint16`

- 枚举类型，返回值是索引，默认值是 0;
- 枚举类型的默认值是第一个值。
  - 枚举类型 enum 至少应该有一名成员。
- 设置的时候，可以设置为索引，也可以对应的枚举名称;
- 枚举类型 enum 可以与整数进行显式转换，但不能进行隐式转换。
  - 显示转换会在运行时检查数值范围，如果不匹配，将会引起异常。

**例子**:考虑一个限制，将交易的状态限制为：`None`/`Pending`/`Shiped`/`Completed`/`Rejected`/`Canceled` 这几种。这将确保交易状态仅在列出的状态内。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Enum {
    // 枚举类型的默认值是第一个值。
    // 结构
    enum Status {
        None, // 0
        Pending, // 1
        Shiped,// 2
        Completed,
        Rejected,
        Canceled
    }
    // 变量
    Status public status;

    // 设置索引值
    function set(Status _status) external {
        status = _status;
    }

    // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，
    // "getStatus" 的签名会自动被改成 "getStatus() returns (uint8)"。
    function getStatus() public view returns (Status) {
        return status;
    }

    function getDefaultStatus() public view returns (uint256) {
        return uint256(status);
    }

    // 设置
    function ship() external {
        status = Status.Shiped;
    }

    // 恢复为0
    function reset() external {
        delete status;
    }
}
```

很多人感觉 enum 很少用，一是因为应用场景确实比较窄，二是因为可以被其他数据类型所代替；但按照编码规范，限制选择范围场景，除了 bool 以外的，推荐使用 enum 类型来定义。

枚举是显示所有整型相互转换，但不允许隐式转换。从整型显式转换枚举，会在运行时检查整数时候在枚举范围内，否则会导致异常（ Panic 异常 ）。

枚举还可以在合约或库定义之外的文件级别上声明。

### 3.9.1 方法

- `type(NameOfEnum).min`
- `type(NameOfEnum).max`

使用 `type(NameOfEnum).min` 和 `type(NameOfEnum).max` 你可以得到给定枚举的最小值和最大值。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Enum {
    // 枚举类型的默认值是第一个值。
    enum Status {
        None,//0
        Pending,//1
        Shiped,//2
        Completed,//3
        Rejected,//4
        Canceled// 5
    }

    function getLargestValue() public pure returns (Status) {
        return type(Status).max;
    }

    function getSmallestValue() public pure returns (Status) {
        return type(Status).min;
    }
}
```

## 3.10 用户定义的值类型

Solidity 允许在一个基本的值类型上创建一个零成本的抽象。这类似于一个别名，但有更严格的类型要求。

用户定义值类型使用 `type UserType is DefaultType` 来定义。

其中 `UserType` 是新引入的类型的名称， `DefaultType` 必须是内置的**值类型**（”底层类型”）。自定义类型的值的数据表示则继承自底层类型，并且 **ABI 中也使用底层类型。**

⚠️: 用户定义的类型 `UserType` 没有任何运算符或绑定成员函数。即使是操作符 `==` 也没有定义。也不允许与其他类型进行显式和隐式转换。

### 3.10.1  方法

- `UserType.wrap()`: 用来从底层类型转换到自定义类型
- `UserType.unwrap()`: 从自定义类型转换到底层类型。

案例：一个 18 位小数、256 bit 的浮点类型

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 使用用户定义的值类型表示 18 位小数、256 bit的浮点类型。
type UFixed256x18 is uint256;

/// 在 UFixed256x18 上进行浮点操作的精简库。
library FixedMath {
    uint constant multiplier = 10**18;

    /// 两个 UFixed256x18 数相加，
    /// 溢出时恢复，依赖于 uint256 上的检查算术
     function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));
    }
    /// 将 UFixed256x18 和 uint256 相乘.
    /// 溢出时恢复，依赖于 uint256 上的检查算术
     function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);
    }
    ///  UFixed256x18 向下取整.
    /// @return 不超过 `a` 的最大整数。
    function floor(UFixed256x18 a) internal pure returns (uint256) {
        return UFixed256x18.unwrap(a) / multiplier;
    }
    /// 将 uint256 转换为相同值的 UFixed256x18。
    /// 如果整数太大，则还原。
    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(a * multiplier);
    }
}

contract Test {
    uint256 a = 1;
    uint256 b = 2;

    function testAdd() external view returns (UFixed256x18) {
        return FixedMath.add(FixedMath.toUFixed256x18(a), FixedMath.toUFixed256x18(b));
    }
    function testMul() external view returns (UFixed256x18) {
        return FixedMath.mul(FixedMath.toUFixed256x18(a),b);
    }
}
```

注意 `UFixed256x18.wrap` 和 `FixedMath.toUFixed256x18` 的签名相同，但执行的是两个完全不同的操作：

- `UFixed256x18.wrap` 函数返回一个与输入的数据表示相同的自定义值类型（`UFixed256x18`）。
- `FixedMath.toUFixed256x18`则返回一个具有相同数值的 `UFixed256x18` 。

# 值类型:地址类型

地址分为外部地址和合约地址，每个地址都有**一块持久化内存区**称为存储。

地址类型也是值类型，因为比较特殊，所以单独拿出来讲。地址类型是 Solidity 语言独有的数据类型，表示以太坊的地址类型。用 address 表示地址，长度是 20 个字节

## 4.1 地址字面常量

通常的地址类型是 `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac` 。 而没有通过校验测试, 长度在 39 到 41 个数字之间的十六进制字面常量，会产生一个错误, 比如 `0XFFD0D80C48F6C3C5387B7CFA7AA03970BDB926AC` 就是一个错误 address 类型，会提示正确的地址

## 4.2 address/uint160/bytes32 之间的转换

- 1 字节 8 位，一个 address 是 20 个字节，是 160 位，所以 **address 可以用 uint160 表示**。

- 1 字节可以表示为两个连续的十六进制数字，所以 **address 可以用连续的 40 个十六进制数字表示**。

- address 不允许任何算数操作

  如果将使用较大字节数组类型转换为 `address` ，例如 `bytes32` ，那么 `address` 将被截断。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    bytes32 public a =
        0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;

    // 0x111122223333444455556666777788889999aAaa
    address public b = address(uint160(bytes20(a)));

    // 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc
    address public c = address(uint160(uint256(a)));
}
```

⚠️：为了减少转换歧义，我们在转换中显式截断处理。 以 32bytes 值 `0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC` 为例， 如果使用 `address(uint160(bytes20(b)))` 结果是 `0x111122223333444455556666777788889999aAaa`， 而使用 `address(uint160(uint256(b)))` 结果是 `0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc` 。

## 4.3 两种形式的地址

- `address`：保存一个 20 字节的值（以太坊地址的大小）。
- `address payable` ：可支付地址，与 `address` 相同，不过有成员函数 `transfer` 和 `send` 。

如果你需要 `address` 类型的变量，并计划发送以太币给这个地址，那么声明类型为 `address payable` 可以明确表达出你的需求。 同样，尽量更早对他们进行区分或转换。

这种区别背后的思想是 `address payable` 可以向其发送以太币，而不能向一个普通的 `address` 发送以太币。比如，它可能是一个智能合约地址，并且不支持接收以太币。

###  两种形式的地址转换

允许从 `address payable` 到 `address` 的隐式转换，而从 `address` 到 `address payable` 必须显示的 通过 `payable(<address>)` 进行转换。也只能通过 `payable(...)` 表达式把 `address` 类型和合约类型转换为 `address payable`。

在介绍地址 payable 方法时候会具体介绍，转换的时候注意下面两个点：

1. 只有能接收以太币的合约类型，才能够进行此转换，合约要么有 receive 或可支付的回退函数。
2. `payable(0)` 是有效的，这是此规则的例外。

## 4.4 地址属性

address 拥有如下属性；

1. .balance : 以 Wei 为单位的余额。

   ```
   <address>.balance    returns(uint256)
   ```

2. .code : 地址上的代码(可以为空)

   ```
   <address>.code        returns(bytes memory)
   ```

3. .codehash : 地址的 codehash

   ```
   <address>.codehash    returns(bytes32)
   ```

### 4.4.1 balance 属性

获取地址的余额，wei 单位。如下例子是获取指定地址的 ETH 余额，和当前调用者的余额。（基于当前使用的网络）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function getBalance1(address addr) public view returns (uint256) {
        return addr.balance;
    }
    function getBalance2() external view returns (uint256) {
        return address(msg.sender).balance;
    }
}
```

可以使用 `address(this).balance` 查询当前合约的余额，获取合约本身的 ETH 余额如下

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
    receive() external payable {}
}
```

⚠️: 在版本 0.5.0 之前，Solidity 允许通过合约实例来访问地址的成员，例如 `this.balance` ，不过现在禁止这样做，必须显式转换为地址后访问，如： `address(this).balance` 。

### 4.4.2 code 属性

可以查询任何智能合约的部署代码。使用 `.code` 来获取 EVM 的字节码，其返回 `bytes memory` ，值可能是空。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function getCode() public view returns (bytes memory) {
        return address(this).code;
    }

    // 外部地址 code 内容是空，
    // 可以通过这个来判断地址是否为合约
    function getAdsCode(address a_) public view returns (bytes memory) {
        return address(a_).code;
    }
}
```

注意:合约没有完全创建，也就是 constructor 没有完全执行完的时候，code 也是空。

### 4.4.3 codehash 属性

使用 `.codehash` 获得合约代码的 `Keccak-256 哈希值` (为 bytes32 )。

注意， `addr.codehash` 比使用 `keccak256(addr.code)` 更便宜。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function getCode() public view returns (bytes memory) {
        return address(this).code;
    }

    function getCodeByKeccak256() public view returns (bytes32) {
        return keccak256(address(this).code);
    }

    function getCodehash() public view returns (bytes32) {
        return address(this).codehash;
    }
}
```

## 4.5 地址方法

address 拥有如下方法；

1. `address()`: 可以将地址转换到地址类型。
2. `payable()`: 将普通地址转为可支付地址。
3. `.transfer(uint256 amount)`: 将余额转到当前地址（合约地址转账）
4. `.send(uint256 amount)`: 将余额转到当前地址，并**返回交易成功状态**（合约地址转账）
5. `.call(bytes memory)`: 用给定的有效载荷（payload）发出低级 `CALL` 调用，并**返回交易成功状态和返回数据**（调用合约的方法并转账）
6. `.delegatecall(bytes memory)`: 用给定有效载荷（payload）发出低级 `DELEGATECALL` 调用，返回交易成功状态和返回数据**（调用合约的方法并转账）
7. `staticcall(bytes memory)`: 用给定的有效载荷（payload）发出低级 `STATICCALL` 调用，并**返回交易成功状态和返回数据**（调用合约的方法并转账）

### 4.5.1 address()

**1.获取当前合约地址:address(this)**

**2.uint 值转换成地址**

### 4.5.2 payable()

注意：支付的时候，地址必须 `payable` 类型！从 `address` 到 `address payable` 的转换。可以通过 `payable(x)` 进行 ，其中 `x` 必须是 `address` 类型。

让普通地址为 payable 有两种方式

- 方式一: 参数中 地址标注 address payable ,并且函数状态可变性标为payable

  - 这种更省 gas (**推荐**)
- 方式二: 仅在内部进行 `payable(address)` 显示转换

### 4.5.3 transfer()

将余额转到当前地址（合约地址转账）,语法如下:

```
<address payable>.transfer(uint256 amount)
```

1. 需要 payable address
2. 使用固定（不可调节）的 2300 gas 的矿工费，错误会 reverts （回滚所有状态）
   1. 2300 gas 足够转账，但是如果接收合约内的 `fallback` 和 `receive` 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。
3. 失败时抛出异常
   1. 如果当前合约的余额不够多，则 `transfer` 函数会执行失败，或者如果以太转移被接收帐户拒绝， `transfer` 函数同样会失败而进行回退。
4. 如果目标地址是一个合约，那么目标合约内部的 receive/fallback 函数会随着调用 `transfer`函数一起执行，这是 EVM 的特性，没办法阻止。

### 4.5.4 send()

将余额转到当前地址，并**返回交易成功状态**（合约地址转账）

```solidity
<address payable>.send(uint256 amount) returns (bool)
send` 是 `transfer` 的低级版本。如果执行失败，当前的合约不会因为异常而终止。`transfer` 等价于`require(send())
```

1. 需要 payable address

2. 使用固定（不可调节）的 2300 gas 的矿工费。

   1. gas 同`transfer`一样的是 2300 gas ；足够转账，但是如果接收合约内的 `fallback` 和 `receive` 函数有恶意代码，复杂代码。容易导致 gas 耗尽的错误。

3. 失败时仅会返回false,不会终止执行（合约地址转账）;

   1. `send()` 执行有一些风险：为了保证安全，必须检查 send 的返回值，如果交易失败，会回退以太币。

4. 补充：send 与 transfer 对应，但 **send 更底层**。如果执行失败，transfer 会因异常停止，而 send 会返回 false,transfer 相对 send 较安全

### 4.5.5 call/delegatecall/staticcall

为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 `call`/`delegatecall`/`staticcall` 直接控制编码。它们都带有一个 `bytes memory` 参数和返回执行**成功状态**（bool）和**数据**（bytes memory）。

函数 `abi.encode`，`abi.encodePacked`，`abi.encodeWithSelector` 和 `abi.encodeWithSignature` 可用于编码结构化数据。

**它们可以接受任意类型，任意数量的参数**。这些参数会被打包到以 32 字节为单位的连续区域中存放。其中一个**例外是当第一个参数被编码成正好 4 个字节的情况**。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。

下面具体的介绍三种 call。

#### 4.5.5.1 call()

用给定的有效载荷（payload）发出低级 `CALL` 调用，并**返回交易成功状态和返回数据**（调用合约的方法并转账）, 格式如下：

```
<address>.call(bytes memory) returns (bool, bytes memory)
```

1. 低级CALL调用：不需要 payable address, 普通地址即可

   1. 注意: 调用 `call` 的时候，地址可以不具备 payable 属性

2. 返回两个参数，一个 `bool` 值代表成功或者失败，另外一个是可能存在的 `data`

3. 发送所有可用 gas，也可以自己调节 gas。

   1. 如果 `fallback` 和 `receive` 内的代码相对复杂也可以，但是如果是恶意代码，需要考虑消耗的 gas 是否值得执行。
   2. `_ads.call{value: msg.value,gas:2300}(data)`

4. 当合约调用合约时，不知道对方源码和 ABI 时候，可以使用 call 调用对方合约

5. 推荐使用 call 转账 ETH，但是不推荐使用 call 来调用其他合约。

   1. 原因是: call 调用的时候，将合约控制权交给对方，如果碰到恶意代码，或者不安全的代码就很容易凉凉。

6. 当调用不存在的合约方法时候，会触发对方合约内的fallback或receive

   1. 我们的合约也可以在 `fallback` / `receive` 这两个方法内抛出事件，查看是否有人对其做了什么操作。

7. 三种方法都提供 `gas` 选项，而 `value` 选项仅 `call` 支持 。三种 call 里只有 `call` 可以进行 ETH 转账，其他两种不可以进行转账。

**例子 （重要）：调用其他合约方法**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test1 {
    string public name;
    uint256 public age;
    address public owner;

    function setNameAndAge(string memory name_, uint256 age_)
        external
        payable
        returns (string memory __name, uint256 __age)
    {
        name = name_;
        age = age_;
        owner = msg.sender;
        return (name_, age_);
    }
}

contract CallTest {
    // 需要一个网页，动态的解析 _bys
    bytes public bys;

    function call_Test1_setNameAndAge(
        address ads_,
        string memory name_,
        uint256 age_
    ) external payable {
        bytes memory data = abi.encodeWithSignature(
            "setNameAndAge(string,uint256)",
            name_,
            age_
        );
        (bool success, bytes memory _bys) = ads_.call{value: msg.value}(data);
        require(success, "Call Failed");
        bys = _bys;
    }
}
```

简单说下这个例子的原理

```solidity
/**
    普通调用:用户A 调用 CallTest 合约, 发送 100 wei ; 
    CallTest 调用 Test1, 发送 50 wei此时在 Test1 合约内部
        msg.sender = CallTest
        msg.value = 50
        Test1 内部如果有状态变量修改，则会被修改
        发送到 Test1 内的ETH主币也会被留在Test1内
 */
```

#### 4.5.5.2 delegatecall() 委托调用

发出低级函数 `DELEGATECALL`，失败时返回 false，发送所有可用 gas，也可以自己调节 gas。

```
<address>.delegatecall(bytes memory) returns (bool, bytes memory)
```

`delegatecall` 使用方法和 `call` 完全一样。区别在于，`delegatecall` 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。`delegatecall` 的目的是使用另一个合约中的库代码。

委托调用是：**委托对方调用自己数据的**。类似授权转账，比如我部署一个 Bank 合约， 授权 ContractA 使用 Bank 地址内的资金，ContractA 只拥有控制权，但是没有拥有权。

- 委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。
  - 利用这个特性，可以通过更换被委托合约，来升级委托合约。
- 委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱
  - 可以通过顺序来避免这个问题，但是推荐完全一样

**例子 1（重要）**

代码如下:

- `DelegateCall` 是委托合约
- `TestVersion1` 是第 1 次被委托合约
- `TestVersion2` 是第 2 次被委托合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 合约版本 V.1
contract TestVersion1 {
    address public sender;
    uint256 public value;
    uint256 public num;

    function set(uint256 num_) external payable {
        sender = msg.sender;
        value = msg.value;
        num = num_;
    }
}

// 合约版本 V.2
contract TestVersion2 {
    address public sender;
    uint256 public value;
    uint256 public num;

    function set(uint256 num_) external payable {
        sender = msg.sender;
        value = msg.value;
        num = num_ * 2;
    }
}

// 委托调用测试
contract DelegateCall {
    address public sender;
    uint256 public value;
    uint256 public num;

    function set(address _ads, uint256 num_) external payable {
        sender = msg.sender;
        value = msg.value;
        num = num_;
        // 第1种 encode
        // 不需知道合约名字，函数完全自定义
        bytes memory data1 = abi.encodeWithSignature("set(uint256)", num_);
        // 第2种 encode
        // 需要合约名字，可以避免函数和参数写错
        bytes memory data2 = abi.encodeWithSelector(TestVersion1.set.selector, num_);

        (bool success, bytes memory _data) = _ads.delegatecall(data2);

        require(success, "DelegateCall set failed");
    }
}
```

简单说下这个例子的原理

```solidity
/**
    委托调用
    用户A 调用 DelegateCall 合约, 发送 100 wei ; DelegateCall 委托调用 Test1
    此时在 Test1 合约内部
        msg.sender = A
        msg.value = 100
        Test1 内部如果有状态变量修改，也不会被修改，会在DelegateCallB 内改变
        发送到 Test1 内的ETH主币，会被留在 DelegateCallB 内，不会在Test1 内
 */
```

#### 4.5.5.3 staticcall() 静态调用

用给定的有效载荷（payload）发出低级 `STATICCALL` 调用，并**返回交易成功状态和返回数据**（调用合约的方法并转账）

```
<address>.staticcall(bytes memory) returns (bool, bytes memory)
```

它与 call 基本相同，发送所有可用 gas，也可以自己调节 gas，**但如果被调用的函数以任何方式修改状态变量，都将回退**。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 被调用的合约
contract Hello1 {
    function echo() external pure returns (string memory) {
        return "Hello World!";
    }
}

contract Hello2 {
    uint8 public a;
    function echo() external returns (string memory) {
        a = 1;
        return "Hello World!";
    }
}

// 调用者合约
contract SoldityTest {
    function callHello(address ads_) external view returns (string memory) {
        // 编码被调用者的方法签名
        bytes4 methodId = bytes4(keccak256("echo()"));

        // 调用合约
        (bool success, bytes memory data) = ads_.staticcall(
            abi.encodeWithSelector(methodId)
        );
        if (success) {
            return abi.decode(data, (string));
        } else {
            return "error";
        }
    }
}
```

### 4.6 三种 call 的总结

1. `call` ， `delegatecall` 和 `staticcall` 都是非常低级的函数，应该只把它们当作最后一招来使用，它们破坏了 Solidity 的类型安全性。
2. 三种方法都提供 `gas` 选项，而 `value` 选项仅 `call` 支持 。所以三种 call 里只有 `call` 可以进行 ETH 转账，其他两种不可以进行转账。
3. 不管是读取状态还是写入状态，最好避免在合约代码中硬编码使用的 gas 值。这可能会引入**错误**，而且 gas 的消耗也是动态改变的。
4. 如果在通过低级函数 `delegatecall` 发起调用时需要访问存储中的变量，那么这两个合约的存储布局需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。 这不是指在库函数调用（高级的调用方式）时所传递的存储变量指针需要满足那样情况。

> ⚠️ 注意: 在 0.5.0 版本以前, `.call`, `.delegatecall` and `.staticcall` 仅仅返回成功状态，没有返回值。

> ⚠️ 在 0.5.0 版本以前, 还有一个 `callcode` 函数，现在已经去除。

### 4.7 transfer / send / call 三种转账的总结

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function byTransfer() public {
        payable(msg.sender).transfer(100);
    }

    function bySend() public {
        bool success = payable(msg.sender).send(100);
        require(success, "Send Fail");
    }

    // 如果使用 transfer 或 send 函数必须添加fallback回退函数
    fallback() external {}

    receive() external payable {}
}
```

低级CALL调用**不需要`payable address`**,transfer 和 send **只能是 `payable address`**

call的 gas 可以动态调整,transfer 和 send 只能是固定制 `2300`

call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账

- 当调用不存在的合约方法时候，会触发对方合约内的 `fallback` 或者 `receive`。
- 如果使用 `_to.call{value: 100}(data)`，那么`data`中被调用的方法必须添加 `payable` 修饰符，否则转账失败！
- 因为可以调用方法，所以 call 有两个参数，除了一个 `bool` 值代表成功或者失败，另外一个是可能存在的 `data`，比如创建合约时候得到部署的地址，调用函数时候得到的函数放回值

### 4.8 注意事项

使用 send 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太币转账安全，总是检查 send 的返回值，利用 transfer 或者下面更好的方式： 用这种接收者取回钱的模式。

**call**:在执行另一个合约函数时，应该尽可能避免使用 .call() ，因为它绕过了类型检查，函数存在检查和参数打包。

由于 EVM 会把对一个不存在的合约的调用作为是成功的。 Solidity 会在执行外部调用时使用 extcodesize 操作码进行额外检查。 这确保了即将被调用的合约要么实际存在（它包含代码）或者触发一个异常。低级调用不 包括这个检查，**这使得它们在 GAS 方面更便宜，但也更不安全**。

上面的这三个 call 方法都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了 Solidity 的类型安全。

# 值类型:合约类型

⚠️ 注意：合约不支持任何运算符。

## 5.1 合约的属性

合约类型的成员是合约的外部函数及 public 的 状态变量。

对于合约 C 可以使用 type(C) 获取合约的类型信息，获得合约名

- ```solidity
  type(C).name
  ```

- ```solidity
  type(C).creationCode
  ```

  - 获得包含创建合约字节码的内存字节数组。
  - 该值和合约内使用 `address(this).code;` 结果一样。
  - 它可以在内联汇编中构建自定义创建例程，尤其是使用 `create2` 操作码。
  - 不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。

- ```solidity
  type(C).runtimeCode
  ```

  - 获得合约的运行时字节码的内存字节数组。这是通常由 `C` 的构造函数部署的代码。
  - 如果 `C` 有一个使用内联汇编的构造函数，那么可能与实际部署的字节码不同。
  - 还要注意库在部署时修改其运行时字节码以防范定期调用（guard against regular calls）。 与 `.creationCode` 有相同的限制，不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。

# 引用类型的额外注解:数据位置

在讲引用类型之前，先介绍数据位置。这是因为在 Solidity 中，引用类型是由简单数据类型组合而成，相比于简单的值类型，这些类型通常通过名称引用。这些类型涉及到的数据量较大，复制它们可能要消耗大量 Gas，所以我们在使用引用数据类型时，必须考虑存储位置。我们需要仔细考虑数据是保存在内存中，还是在 EVM 存储区中。这就是线介绍数据位置的原因。

**注意：所有的引用类型，都有数据位置这个额外的注解来指定存储在哪里，所以一定要掌握好。**

## 6.1 数据位置的基础介绍

在合约中声明和使用的变量都有一个数据位置，合约变量的数据位置将会影响 Gas 消耗量。

Solidity 提供的有三种如下数据位置。

- 存储 storage : 状态变量保存的位置，只要合约存在就一直存储．
- 内存 memory : 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。
- 调用数据 calldata : 用来保存函数参数的特殊数据位置，是一个**只读位置**。
  - 调用数据 calldata 是不可修改的、非持久的函数参数存储区域，效果大多类似 内存 memory 。
  - 主要用于外部函数的参数，但也可用于其他变量，无论外部内部函数都可以使用。

核心：更改数据位置或类型转换将始终产生自动进行一份拷贝，而在同一数据位置内（对于 存储 storage 来说）的复制仅在某些情况下进行拷贝。

### 6.1.1 storage

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocation {
    // storage
    uint256 stateVariable = 1;
    uint256[] stateArray = [1, 2, 3];

    // uint storage stateVariable; // Expected identifier but got 'storage'
    // uint[] memory stateArray; // Expected identifier but got 'memory'
}
```

该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。保存在存储区(storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。

storage 是永久存储在以太坊区块链中，更具体地说存储在存储 Merkle Patricia 树中，**形成帐户状态信息的一部分**。一旦使用这个类型，数据将永远存在。

**重点:状态变量总是存储在存储区(storage)中,并且不能显式地标记状态变量的位置。**。状态变量是强制为 storage。

### 6.1.2  memory

内存位置是临时数据，比存储位置便宜。它只能在函数中访问。通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。

memory：**存储在内存中，即分配、即使用，越过作用域则不可访问，等待被回收**。

##### **重点 1:函数参数(包括返回参数)都存储在内存中。**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocation {
    function add(uint256 num1, uint256 num2)
        public
        pure
        returns (uint256 result)
    {
        return num1 + num2;
    }
}
```

上面例子中: 函数参数 `uint num1` 与 `uint num2`，返回值 `uint result` 都存储在内存中。

##### **重点 2:引用类型的局部变量，需要显式指定数据位置(storage/memory)**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Locations {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public java; // 一本 java 书
    mapping(address => uint256) public balances;

    function test() public {
        /* 此处都是局部变量  */
        // 值类型:所以它们被存储在内存中
        bool flag = true;
        uint256 number = 1;
        address account = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;
        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff)));

        // Data location can only be specified for array, struct or mapping types,
        // but "memory" was given.
        // bool memory flag2; // 错误:值类型的数据不能标示 memory

        // 引用类型:需要显示指定数据位置，此处指定为内存
        uint256[] memory localArray; // array
        // uint8[] memory nums = [1, 2, 3]; // 内存中不能创建动态数组
        uint8[3] memory numsFixed = [1, 2, 3];
        uint256[] memory a = new uint256[](5); // 推荐
        a[1] = 1;
        a[2] = 2;
        a[3] = 3;
        a[4] = 4;

        string memory myStr = "hello"; // string

        // 映射不能在函数中动态创建，您必须从状态变量中分配它们。
        // mapping(address => bool) memory myMapping;
        mapping(address => uint256) storage ref = balances; // mapping
        java = Book({title: "Solidity", author: "Anbang", book_id: 1}); // struct
        bytes memory bc = bytes("!"); //
    }
}
```

- mapping 和 struct 类型，不能在函数中动态创建，必须从状态变量中分配它们。
- 内存中不能创建动态数组

##### **重点 3:函数的输入和输出参数如果是数组,使用 memory**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocations {
    // name_ 是 string ，所以使用 memory
    // mm_ 是 uint256[] ，所以使用 memory
    // 输出相同，也是使用 memory
    function examples2(string memory name_, uint256[] memory mm_)
        external
        pure
        returns (uint256[] memory memArr, string memory myName)
    {
        memArr = new uint256[](mm_.length);
        myName = name_;
        for (uint256 index = 0; index < mm_.length; index++) {
            memArr[index] = mm_[index];
        }
    }
}
```

##### **重点 4:引用类型的局部变量:指定 storage 和 memory 的区别**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocations {
    struct MyStruct {
        string name;
        uint256 age;
    }
    mapping(address => MyStruct) public myStructs;

    function test1() external returns (MyStruct memory) {
        myStructs[msg.sender] = MyStruct({name: "Anbang1", age: 18});

        // storage 会修改状态变量
        MyStruct storage myStruct1 = myStructs[msg.sender];
        myStruct1.age++;
        return myStruct1;
    }

    function test2() external returns (MyStruct memory) {
        myStructs[msg.sender] = MyStruct({name: "Anbang2", age: 18});

        // memory 函数运行完后即消失，修改的值也不会储存在状态变量中
        MyStruct memory myStruct2 = myStructs[msg.sender];
        myStruct2.age++;
        return myStruct2;
    }
}
```

- `storage`修改引用数据: 会修改状态变量
- `memory`修改引用数据: 函数运行完后即消失，修改的值也不会储存在状态变量中

### 6.1.3  calldata

calldata 是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，`calldata` 是外部函数(external function)的参数的默认位置。外部函数(external function)的参数存储在 calldata 中。函数的返回值中也可以使用 calldata 数据位置的数组和结构，但是无法给其分配空间。

- **要点: calldata 只能用在函数的输入和输出参数中**
- **要点: calldata 用在输入参数中，比 memorg 更省 gas**
- **要点: calldata 的参数不允许修改，但是 memorg 参数允许修改**

存储函数参数，它是只读的，不会永久存储的一个数据位置。外部函数(external function)的参数被强制指定为 calldata，效果与 memory 类似。

> 注解: 如果可以的话，请尽量使用 calldata 作为数据位置，因为它将避免复制，并确保不能修改数据。

### 6.1.4 stack

堆栈是由 EVM (Ethereum 虚拟机)维护的非持久性数据。EVM 使用堆栈数据位置在执行期间加载变量。堆栈位置最多有 1024 个级别的限制。

### 6.1.5 小结

按照关键字:

- storage: 存储区: 状态变量总是储存在**存储区**上
- memory: 内存区: 局部变量使用，只在内存中生效。
  - 值类型的局部变量，存储在**内存**中。
  - **引用类型局部变量，需要显式地指定数据位置**。
  - 函数的输入参数如果是数组或者 string，必须是 `memory` 或 `calldata`
  - 内存中的数组必须是定长数组（不能使用 push 赋值），动态数组只能储存在状态变量中。
- calldata
  - 和 memory 类似，但是 calldata 只能用在函数的输入参数中。
  - 相比使用 memory ,合约输入参数如果使用 calldata, 可以节约 gas

按照函数参数:

- 内部函数参数: (包括返回参数)都存储在**memory（内存）**中。
- 外部函数参数: (不包括返回参数)存储在 `calldata` 中。

## 6.2 不同数据位置之间的赋值规则

本小节总结如下:

1. 将存储变量赋值给存储变量

   - `值 类 型`: 创建一个新副本。
   - `引用类型`: 创建一个新副本。

2. 将内存变量赋值给存储变量

   - `值 类 型`: 创建一个新副本。
   - `引用类型`: 创建一个新副本。

3. 将存储变量赋值给内存变量

   - `值 类 型`: 创建一个新副本。
   - `引用类型`: 创建一个新副本。

4. 将内存变量赋值给内存变量 (同类型)

   - `值 类 型`: 创建一个新副本。
   
   - `引用类型`: 不会创建副本。(**重要**)

## 6.3 calldata 和 memeory 区别

**函数调用函数时的区别**: `calldata可以隐式转换为memory`

- calldata 参数可以隐式转换为 memory
- memory 参数不可以隐式转换为 calldata

# 引用类型

- array

  - 基本类型组成的数组集合。

  ```solidity
  uint256[5] public T1 = [1, 2, 3, 4, 5];
  address[5] public A = [0xff...6ac];
  byte[5] public A = [0xff...6ac];
  ```

  - 字符串与 bytes 是特殊的数组，所以也是引用类型

- string: 是一个动态尺寸的 utf-8 编码字符串

  - 他其实是一个特殊的可变字节数组，同时其也是一个引用类型

- bytes: 动态十六进制字节数组

  - bytes 类似于 `byte[]`，但它在 calldata 中被紧密地打包。因此，相比于 `byte[]`，bytes 应该优先使用，因为更便宜。
  - string 等价于 bytes，但不允许长度或索引访问。

- mapping

- struct：为了允许 evm 的优化，请确保 storage 中的变量和 `struct` 成员的书写顺序允许它们被紧密地打包。例如，应该按照 `uint128，uint128，uint256` 的顺序来声明状态变量，而不是使用 `uint128，uint256，uint128`，因为前者只占用两个存储插槽，而后者将占用三个。

## 7.1 array 数组

数组是存储**同类元素的有序集合**。数组声明时可以是固定大小的，也可以是动态调整长度。

下面是 array 的总结:

- 声明和初始化数组

  - 数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在存储 storage 中，并且公开访问函数的参数需要是 ABI 类型。

- 访问和修改数组元素

  - ```solidity
    arr[_index]
    ```

    - 通过索引进行获取特定元素

  - 可以通过索引修改值

  - 状态变量标记 `public` 的数组，Solidity 创建一个 `getter函数` 。 下标的索引数字就是 `getter函数` 的参数。

  - 访问超出数组长度的元素会导致异常（assert 类型异常 ）。 可以使用 .push() 方法在末尾追加一个新元素，其中 .push() 追加一个零初始化的元素并返回对它的引用。

- 函数中返回数组

  - 如果想把数组全部返回，需要通过函数进行操作。在函数中返回数组

- 动态数组和定长数组

  - 动态数组只能存在于状态变量中
  - 内存中只能创建定长数组

- 创建内存数组

  - 对于 storage 数组，元素可以是任意类型(其他数组、映射或结构)。
  - 对于 memory 数组，元素类型不能是映射类型，如果它是一个 public 函数的参数，那么元素类型必须是 ABI 类型。

- 数组的属性

  - `length`: 获取数组的长度

- 数组的方法

  - push : 只有动态数组可以使用，只能用在动态数组上
  - pop: 删除最后一个长度，只能用在动态数组上
  - delete: 清空对应的索引；清空不是删除，并不会改变长度，索引位置的值会改为默认值。
  - 数组切片: `x[start:end]`

### 7.1.1 数组的创建

数组长度上分为 **固定长度数组** 和 **可变长度数组**，类型上分为**一维数组**和**多维数组**；

一个元素类型为 `T`，固定长度为 `k` 的数组可以声明为 `T[k]`，而动态数组声明为 `T[]`。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // 固定长度数组
    address[5] public A =   [0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac];
    uint256[10] public arr1 = [0, 1, 2]; // 赋值的数组长度不超过10都可以
    uint256[10] public arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    
    //先声明再赋值
    uint256[10] public arr1;
    function test() external {
        arr1[0] = 1;
        arr1[1] = 10;
        arr1[2] = 100;
        arr1[9] = 900;
    }
    
    // 可变长度数组
    /*
         用方式 2 创建数组时，若数组为成员变量, 则默认为 storage 类型；
         若为局部变量默认为 `memory` 类型，`memory` 类型的数组，必须声明长度，并且长度创建后不可变。
         `push` 方法不能用在 `memeory` 的数组上,只能逐个索引的赋值。
     */
    uint256[] public T1 = [1, 2, 3, 4, 5]; // 方式 1
    uint256[] public T2 = new uint256[](5); // 方式 2
    
    //二维数组:创建（注意这里跟其它语言比，数组长度的声明位置是反的）
    uint256[2][3] public T = [[1, 2], [3, 4], [5, 6]];
}
```

**如果能使用定长数组，就使用定长数组，因为它很便宜。**

### 7.1.2 数组常量

正常看到下方代码应该没什么问题，但是注意:函数 s 中数组类型是`uint256`，而函数 t 中输入的数组类型是`uint8`, 这里需要将 uint8 转换一下`s([uint256(1), uint256(2)]);`;

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract T {
    function s(uint256[2] memory _arr) public {}

    function t() public {
        // s([1, 2]); // 默认这么写不行的 ❌
        s([uint256(1), uint256(2)]); // ✅
    }
}
```

能转成小的类型，就不会转成大的，这是数组常量的**懒惰性**。如下是一个比较经典的例子

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract T {
    int8[2] public a = [1, -1];
    // int8[2] public a = [int8(1), -1];
}
```

数组常量 `[1, -1]` 是无效的，因为第一个表达式类型是 `uint8` 而第二个类似是 `int8` 他们不可以隐式的相互转换。 为了确保可以运行，你是可以使用例如： `[int8(1), -1]` 。

由于不同类型的固定大小的内存数组不能相互转换(尽管基础类型可以)，如果你想使用二维数组常量，你必须显式地指定一个基础类型:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function f() public pure returns (uint24[2][4] memory) {
        // 下面代码无法工作，因为没有匹配内部类型
        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];

        uint24[2][4] memory x = [
            [uint24(0x1), 1],
            [0xffffff, 2],
            [uint24(0xff), 3],
            [uint24(0xffff), 4]
        ];

        return x;
    }
}
```

### 7.1.2 数组的属性

##### length数组有 `length` 属性表示当前数组的长度。 一经创建，内存 memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。

**通过 `arr.length` 获取数组的长度**

**不能通过设置 `arr.length` 来调整动态数组的长度。**

### 7.1.3 数组的方法

- push : 只有动态数组可以使用，动态的 storage 数组以及bytes类型可以用，string类型不可以

  - `push()`: 它用来添加新的零初始化元素到数组末尾，并返回元素引用.因此可以这样：`x.push().t = 2` 或 `x.push() = b`.
  - `push(x)`: 用来在数组末尾添加一个给定的元素，这个函数没有返回值．

- `pop:` 删除最后一个长度
  - 它用来从数组末尾删除元素。 同样的会在移除的元素上隐含调用 delete 。

- `delete`: 删除对应的索引；删除并不会改变长度，索引位置的值会改为默认值。

- `x[start:end]`: 数组切片，仅可使用于 `calldata` 数组.

## 7.2.bytes

`string` 和 `bytes` 类型的变量是特殊的数组。 `bytes` 可以通过索引或者`.length`来访问数据。string 与 bytes 相同，但不允许用`.length`或索引来访问数据。

- 对任意长度的原始字节数据使用 `bytes`，对任意长度字符串（UTF-8）数据使用 `string` 。
- 如果使用一个长度限制的字节数组，应该使用一个 `bytes1` 到 `bytes32` 的具体类型，因为它们便宜得多。
- `bytesN[]` 和 `bytes` 可以转换: bytes1 是值类型，比如 `0x61`; `bytes`是可变字节数组,如果 bytes1 想要借用 bytes 的方法，就需要转换成 bytes;

### 7.2.1 创建

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome = bytes("1.Welcome");
    bytes public temp1 = new bytes(2); // 可变字节数组创建方式
}
```

### 7.2.2 bytes 和 bytes32[] 区别

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// bytes / bytes32 / bytes32[] 区别
// bytes:可变字节数组 ： 引用类型
// bytes32: 固定长度的字节数组 ： 值类型
// bytes32[]: 由“固定长度的字节数组” 组成的 数组类型
contract Demo {
    bytes public welcome1 = bytes("1.Welcome");
    bytes32 public welcome2 = "a";
    bytes32[] public welcome3 = [bytes32("a")];

    bytes32[] public abcArray = [bytes1("a"), bytes1("b"), bytes1("c")];

    // 0x616263
    bytes public abcBytes = bytes("abc");


}
```

`abcBytes` 的值是: `0x616263`;

`abcArray` 的值是:

```solidity
[
    0x6100000000000000000000000000000000000000000000000000000000000000,
    0x6200000000000000000000000000000000000000000000000000000000000000,
    0x6300000000000000000000000000000000000000000000000000000000000000
]
```

`bytes` 有点类似于 `bytes1[]`的紧打包，我们可以把上面例子中 bytes32 改为 bytes1 类型进行对比。

我们更多时候应该使用 `bytes` 而不是 `bytes32[]`这种数组类型 ，因为 Gas 费用更低;

- `bytes32[]` 会在元素之间添加 31 个填充字节。
- `bytes` 由于紧密包装，这没有填充字节。

### 7.2.3  属性

- 获取 bytes 长度

  - bytesVar.length:以字节长度表示字符串的长度

- 获取指定索引的数据

  ```solidity
  bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1
  ```

### 7.2.4 方法

#### bytes.concat 拼接

- `bytes.concat(...) returns (bytes memory)`
- `bytes.concat( )`返回空数组

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public concatBytes = bytes.concat();
    bytes public welcome = bytes("a");
    bytes public concatBytes = bytes.concat(welcome, bytes("b"), bytes1("c"),"a");
}
```

#### push 方法

注意： push 是单个字节，是 `bytes1`的固定长度,而不是 `bytes`。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome1 = bytes("Welcome");
    bytes public welcome2 = new bytes(10);

    function testPush() public {
        welcome1.push(bytes("A")[0]);
        welcome2.push(bytes1("B"));
    }
}
```

#### pop 方法

删除数组的最后一个元素。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome1 = bytes("Welcome");
    bytes public welcome2 = new bytes(10);

    function testPop() public {
        welcome1.pop();
        welcome2.pop();
    }
}
```

#### delete 清空字节数组

使用 `delete` 全局关键字;

- `delete bytesName`
- `delete bytesName[index]`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome1 = bytes("Welcome");

    function deleteAll() public {
        delete welcome1;
    }

    function deleteIndex(uint256 index_) public {
        delete welcome1[index_];
    }
}
```

#### `x[start:end]`:数组切片

注意：数组切片只能用在 calldata 类型上。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Proxy {
    bytes public welcome1 = bytes("Welcome");
    bytes4 public temp1 = bytes4(welcome1); // 0x57656c63

    // 把 welcome1 的值传入参数
    function forward(bytes calldata payload)
        external pure
        returns(bytes memory temp2,bytes4 temp3)
    {
        // 切片方法只能用在 calldata 上。
        temp2 = payload[:4];
        temp3 = bytes4(payload[:4]);
    }
}
```

### 7.2.5 字符串 到 bytes 的转换

转换方法: 可以使用 `bytes()` 构造函数将字符串转换为 `bytes`。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function trans(string memory _str) external pure returns (bytes memory) {
        return bytes(_str);
    }
}
```

### 7.2.6 bytes 到 字符串 的转换

转换方法: 可以使用 `string()` 构造函数将 `bytes` 转换为字符串。

注意: 字节数组分为动态大小和固定大小的。如果是固定大小字节数组，需要先转为动态大小字节数组。

- `动态大小字节数组` —> `string`
- `固定大小字节数组` —> `动态大小字节数组` —> `string`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string public data1;
    string public data2;

    // `动态大小字节数组` —> `string`
    function trans1() external {
        bytes memory bstr = new bytes(2);
        bstr[0] = "a";
        bstr[1] = "b";
        data1 = string(bstr);
    }

    // `固定大小字节数组` —> `动态大小字节数组` —> `string`
    function trans2() external {
        // 固定大小字节数组
        bytes2 ab = 0x6162;

        // `固定大小字节数组` —> `动态大小字节数组`
        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式
        for (uint256 i = 0; i < ab.length; i++) {
            temp[i] = ab[i];
        }

        // `动态大小字节数组` —> `string`
        data2 = string(temp);
    }
}
```

## 7.3 string

Solidity 中，字符串值使用双引号(`""`)或单引号(`''`)包括，字符串类型用 string 表示。`string` 和 `bytes` 类型的变量是特殊的数组，是引用类型。

### 7.3.1 格式

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract For {
    string public a = "a" "b" "c";
    string public b = "abc";
    string public c = 'x' 'y' 'z';
    string public d = 'xyz';
}
```

### 7.3.2 属性

string 并没有获取其字符串长度的 length 属性; 也没提供获取某个索引字节码的索引属性。

我们可以通过把 string 转换成 `bytes`，借助`bytes` 的属性。

例子: 下面是使用 `getLength()` 获取长度，使用`modi()`修改字符串，使用 `getIndexValue()` 获取字符串的指定索引的数据。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    string public welcome = "1.Welcome";

    function getLength() public view returns (uint256 welcomeLength) {
        welcomeLength = bytes(welcome).length;
    }

    function getIndexValue(uint256 _index) public view returns (string memory) {
        bytes1 temp1 = bytes(welcome)[_index]; // 返回固定长度的 bytes1
        bytes memory temp2 = new bytes(1); // 可变字节数组创建方式
        temp2[0] = temp1;
        return string(temp2);
    }

    function modi() public {
        bytes(welcome)[0] = bytes1("2");
    }
}
```

### 7.3.3 方法

Solidity string 本身并没有操作函数，需要借助全局的函数

- 字符串拼接
  - `string.concat()`
  - 如果不使用参数调用 string.concat 将返回空数组。
- 将 bytes 转换到字符串
  - `string()`
- 将 字符串 转换到 bytes
  - `bytes()`
- 比较两个字符串
  - `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`
  - `keccak256(bytes(s1)) == keccak256(bytes(s2))`:更省 gas

**string.concat**:可以使用 `string.concat` 连接任意数量的 string 字符串。 该函数返回一个 `string memory` ，包含所有参数的内容，无填充方式拼接在一起。 如果你想使用不能隐式转换为 string 的其他类型作为参数，你需要先把它们转换为 string。

输入字符串，输出拼接后的字符串

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    string public welcome = "Welcome";

    // 写一个 welcome username 的小方法
    // Welcome Anbang!
    function test(string memory name_)
        public
        view
        returns(string memory concatString){
            bytes memory bs = bytes("!");
            // welcome + name_ + bs
            // 内部是使用字符串，如果是bytes，需要转换为 string 类型
            concatString = string.concat(
                welcome,
                name_,
                string(bs)
            );
        }
}
```

如果你不使用参数调用 `string.concat` 或 `bytes.concat` 将返回空数组。

## 7.4 mapping 映射

mapping 可以看作一个哈希表，会执行虚拟化初始化，使所有可能的值都是该类型的默认值。其实 mapping 并不是一个哈希表，没有 key 集合，也没有 value 集合，所以 mapping 没办法遍历/迭代。

数组中找某一个值需要循环遍历，这是很消耗 Gas 的，而使用 mapping 就可以很好的解决这个问题。映射可以很方便的获取某个值。映射并没有做迭代的方法。

### 7.4.1本节重点

声明映射类型的语法：`mapping(_KeyType => _ValueType)`

`_KeyType`：可以是任何内置类型，或者 bytes 和 字符串,键是唯一的，其赋值方式为：`map[a]=test`; 意思是键为 a,值为 test；

`_ValueType`： 可以是任何类型，用户自定义类型也可以。

mapping 支持嵌套,映射的数据位置(data location)只能是 `storage`，通常用于状态变量,mapping不能用于public

函数的参数或返回结果

- 映射只能是 storage 的数据位置，因此只允许作为状态变量 或 作为函数内的 storage 引用 或 作为库函数的参数。它们不能用**合约公有函数的参数或返回值**。
- 这些限制同样适用于包含映射的数组和结构体。

**问答题：为什么映射不能像哈希表一样遍历？**

映射与哈希表不同的地方：**在映射中,并不存储 key，而是存储它的 `keccak256` 哈希值，从而便于查询实际的值**。正因为如此，映射是没有长度的，也没有 `key 的集合`或 `value 的集合`的概念。映射只能是存储的数据位置，因此只允许作为状态变量或作为函数内的存储引用 或 作为库函数的参数。

### 7.4.2 创建格式

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Mapping {
    // 普通
    mapping(address => uint256) public balances;
    // 嵌套
    mapping(address => mapping(address => bool)) public friends;
}
```

### 7.4.3 如何获取-设置-删除

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Mapping {
    // 普通
    mapping(address => uint256) public balances;

    // 嵌套
    mapping(address => mapping(address => bool)) public friends;

    constructor() {
        balances[msg.sender] = 100;
    }

    function blanceGet() external view returns (uint256) {
        // 获取
        return balances[msg.sender];
    }

    function blanceSet(uint256 amount) external {
        // 设置
        balances[msg.sender] += amount;
    }

    function blanceDelete() external {
        // 删除
        delete balances[msg.sender];
    }

    function friendGet() external view returns (bool) {
        // 获取
        return friends[msg.sender][address(0)];
    }

    function friendSet() external {
        // 设置
        friends[msg.sender][address(0)] = true;
    }

    function friendDelete() external {
        // 删除
        delete friends[msg.sender][address(0)];
        // delete friends[msg.sender];
    }
}
```

### 7.4.4 作为局部变量的使用

`mapping` 类型可以用做局部变量，但只能引用状态变量，而且存储位置为 storage。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 作为局部变量的使用
contract Demo {
    // 普通 mapping
    mapping(address => uint256) public balances; // 普通mapping

    // storage: 改变内部 ref，会影响 balances 的值
    // 不能声明为 memory
    function updataBalance() public returns(uint256){
        // mapping(address=>uint256) memory ref = balances; // ❌
        mapping(address=>uint256) storage ref = balances;
        ref[msg.sender] += 3;
        return ref[msg.sender];
    }

}
```

### 7.4.5 在 ERC20 token 中的用法

下面的例子是ERC20 token的简单版本 `._allowances` 是一个嵌套 mapping 的例子 `._allowances` 用来记录其他的账号，可以允许从其账号使用多少数量的币．

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// mapping 在 ERC20 token 中的用法
contract MappingExample {
    // 余额
    mapping(address => uint256) private _balances;
    // 授权:
    // 授权人 - 代理人 - 授权金额
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    // 获取：授权金额
    function allowance(address owner, address spender)
        public
        view
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    // 检查：授权金额大于等于需要操作的金额
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public returns (bool) {
        require(
            _allowances[sender][msg.sender] >= amount,
            "ERC20: Allowance not high enough."
        );
        _allowances[sender][msg.sender] -= amount; // 设置额度
        _transfer(sender, recipient, amount);
        return true;
    }
    // 设置：
    function approve(address spender, uint256 amount) public returns (bool) {
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(_balances[sender] >= amount, "ERC20: Not enough funds.");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }
}
```

### 7.4.6 可迭代映射

遍历所有 Mapping 内的数据，（Mapping 配合 array ）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    mapping(address => uint256) public balances;
    // 用于检查:地址是否已经存在于 balancesKey
    mapping(address => bool) public balancesInserted;
    address[] public balancesKey; // 所有地址

    // 设置
    function set(address ads_,uint256 amount_) external{
        balances[ads_] = amount_;
        // 1.检查
        if(!balancesInserted[ads_]){
            // 2.修改检查条件
            balancesInserted[ads_] = true;
            // 3.正在的操作
            balancesKey.push(ads_);
        }
    }
    // 获取
    function get(uint256 index_) external view returns(uint256){
        require(index_<balancesKey.length,"index_ error");
        return balances[balancesKey[index_]];
    }
    // 获取所有
    function totalAddress() external view returns(uint256){
        return balancesKey.length;
    }

    // 获取第一个值
    function first() external view returns(uint256){
        return balances[balancesKey[0]];
    }
    // 最后一个值
    function latest() external view returns(uint256){
        return balances[balancesKey[balancesKey.length-1]];
    }
}
```

- 更完善的实现: https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol
- 更新的实现: https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings

## 7.5 struct 结构体

### 7.5.1 创建语法

要定义结构体，使用 `struct` 关键字。`struct` 关键字定义了一个新的数据类型，包含多个成员。结构体是可以将多个变量进行编组的自定义类型

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
}
```

### 7.5.2 三种创建方法

```solidity
// 第 1 种生成
Book memory solidity1 = Book(unicode"Solidity 高级程序设计", "Anbang", ++bookId);

// 第 2 种生成
Book memory solidity2 = Book({
    title: unicode"Solidity 高级程序设计",
    author: "Anbang",
    book_id: ++bookId,
});

// 第 3 种生成
Book memory temp;
temp.title = unicode"Solidity 高级程序设计";
temp.author = "Anbang";
temp.book_id = ++bookId;
```

### 7.5.3 读取

函数内仅读取结构体，使用 memory 和 storage 区别:

1. 函数内读取并返回,如果使用 memory 变量接收:
   1. 从状态变量拷贝到内存中，然后内存中的变量拷贝到返回值。两次拷贝，消耗 gas 多
   2. `Book memory _book = book;`
2. 函数内读取并返回，如果使用 storage 变量接收:
   1. 直接从状态变量读取，状态变量拷贝到返回值。1 次拷贝，消耗 gas 小
3. 总结: 读取时候推荐使用 `storage`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 读取
contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public book = Book("Solidity", "Anbang", 1);

    // memory  30029 gas
    // 函数内读取并返回：使用 memory 变量接收
    //  两次拷贝，所以消耗的 gas 多
    function get1() external view
        returns(
            string memory,
            string memory,
            uint256
        )
    {
         // 从状态变量拷贝到内存中
        Book memory _book = book;
        // 内存中的变量拷贝到返回值；2次拷贝
        return (_book.title,_book.author,_book.book_id);
    }

    // storage 29983 gas
    // 函数内读取并返回：使用 storage 变量接收
    function get2() external view
        returns(
            string memory,
            string memory,
            uint256
        )
    {
        // 从状态变量读取，没有拷贝的行为
        Book storage _book = book;

        // 状态变量拷贝到返回值。1次拷贝
        return (_book.title,_book.author,_book.book_id);
    }

}
```

### 7.5.4 修改

函数内读取时，标记 `memory` / `storage`,会产生完全不同的结果；

特别注意：**如果结构体内包含 `mapping` 类型，则必须使用 `storage`，不可以使用 memeory.**，否则报错

函数内获取并修改结构体：

- 因为要修改状态变量，所以使用 storage
- 函数内直接修改变量; 在修改一个属性时比较省 Gas 费用
- 函数内先获取存储到 storage 再修改:修改多个属性的时候比较省 Gas 费用

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Structs {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    uint256 private bookId;
    Book public book1; // Book类型
    Book public book2; // Book类型

    mapping(address => Book) public students; // mapping 类型

    // 设置 book1
    function setBook1() external {
        Book memory temp;
        temp.title = unicode"Solidity 高级程序设计";
        temp.author = "Yaoqi";
        temp.book_id = ++bookId;
        book1 = temp;
    }

    // 设置 book2
    // ✅ 最优方案，推荐:直接修改
    function setBook2() external {
        book2.title = unicode"Solidity 高级程序设计";
        book2.author = "Yaoqi";
        book2.book_id = ++bookId;
    }

    // ✅ 最优方案，推荐:直接修改
    function set1Student() external {
        Book storage temp = students[msg.sender];
        temp.title = unicode"Solidity 高级程序设计";
        temp.author = "Anbang";
        temp.book_id = ++bookId;
    }

    function set2Student() external {
        Book memory temp;
        temp.title = unicode"Solidity 高级程序设计";
        temp.author = "Anbang";
        temp.book_id = ++bookId;
        students[msg.sender] = temp;
    }
}
```

### 7.5.5 删除

删除结构体的变量，仅仅是重置数据，并不是完全的删除。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public book = Book("Solidity", "Anbang", 1);

    function del() external
    {
        delete book;
    }
}
```

# 类型转换

Solidity 允许类型之间进行隐式转换和显式转换。

**前文回顾**: `bytes1` 对应 `uint8`，对应两位连续的十六进制数字 `0xXX`。

## 8.1 隐式转换

### 8.1.1 发生场景

在**赋值**, **函数参数传递**以及应用运算符时，会发生隐式转换。

### 8.1.2  转换的标准

1. 值类型
2. 源类型必须是目标类型的子集。

例如，`uint8` 可以转换为 `uint16`/`uint24`../`uint256`，因为`uint8`是`uint16`这些类型的子集。

但是 `int8` 不可以转换为 `uint256`，因为 `int8` 可以包含 `uint256` 中不允许的负值，比如 `-1`。

### 8.1.3  相交集合的类型，不能隐式转换。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    int8 public a1 = 3;

    // Type int8 is not implicitly convertible to expected type uint16.
    // uint16 public a2 = a1;

    uint8 public b1 = 3;
    uint16 public b2 = b1;
}
```

### 8.1.4 把整数字面量赋值给整型时，不能超出范围而发生截断，否则会报错。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo1 {
    uint8 public a = 12; // no error
    uint32 public b = 1234; // no error
    uint16 public c = 0x01;

    // Type int_const 123456 is not implicitly convertible
    // to expected type uint8. Literal is too large to fit in uint8.
    // uint8 d = 123456;
}
```

### 8.1.4 函数参数传递

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 函数的传参
contract Demo {
    uint256 public a;

    function test1(uint256 u_) public {
        a = u_;
    }

    function test2() external {
        uint8 temp = 3;
        test1(temp); //
    }
}
```

数组：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 函数的传参
contract Demo {
    uint256 public a;

    function test1(uint256[3] memory u_) public {
        a = u_[0];
    }

    // 禁止的：
    function test2() external {
        // function call. Invalid implicit conversion from uint8[3]
        // memory to uint256[3] memory requested.
        // test1([1,2,3]);
        test1([uint256(1),uint256(2),uint256(3)]);
    }
}
```

### 8.1.5 运算符应用

则编译器将尝试将**其中一个操作数**隐式转换为**另一个操作数的类型**（赋值也是如此）。 这意味着操作始终以操作数之一的类型执行。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 运算符
contract Demo {
    uint8 public  x = 1;
    uint16 public  y = 2;

    // uint8 + uint16 => uint16 + uint16 = uint16
    // uint16 => uint32
    uint32 public  z = x + y;
}
```

在上面的示例中，加法的操作数 x 和 y 没有相同的类型，uint8 可以被隐式转换为 uint16，相反却不可以。 因此在执行加法之前，将 uint8 转换为 uint16 的类型，结果类型是 uint16。因为它被赋值给 uint32 类型的变量，又进行了另一个类似逻辑的隐式转换.

## 8.2 显式转换

可以使用类型关键字，显式地将数据类型转换为另一种类型。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // uint8 => uint16
    uint8 public a1 = 3;
    uint16 public a2 = uint16(a1);

    int8 public b1 = 3;
    //Explicit type conversion not allowed from "int8" to "uint256".
    // uint256 b2 = uint256(b1);
}
```

### 8.2.1 int/uint 整型转换

整型加大数据位置是从左侧增加，减小数据位置也是从左侧移除；（**整型是右对齐**）

- 整型转换成更大的类型，从左侧添加填充位。
- 整型转换成更小的类型，会丢失左侧数据。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // 整型转换成更大的类型，从左侧添加填充位。
    // uint16 => uint32
    uint16 public a1 = 22136;       // 等于 0x5678
    uint32 public a2 = uint32(a1); // a2 = 22136

    // uint16 => uint8
    uint8 public a3 = uint8(a1); // a4 = 0x78
    uint8 public a4 = 0x78;

    // 整型转换成更小的类型，会丢失左侧数据。
    // uint32 => uint16
    uint32 public b1 = 0x12345678; // 0x12345678
    uint16 public b2 = uint16(b1); // 0x5678 | b2 = 22136
}
```

**整数显式转换为更大的类型**

```solidity
uint16 a = 0x1234;
uint32 b = uint32(a); // b 为 0x00001234 now
```

**整数显式转换成更小的类型**

```solidity
uint32 a = 0x12345678;
uint16 b = uint16(a); // 此时 b 的值是 0x5678
```

### 8.2.1 bytes 字节类型转换

字节加大数据位置是从右侧增加，减小数据位置也是从右侧移除；（**字节是左对齐**）

- 字节转换为更大的类型时，从右侧添加填充位。
- 字节转换到更小的类型时，丢失右侧数据。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // 字节转换为更大的类型时，从右侧添加填充位。
    // bytes2 =>bytes4
    bytes2 public a1 = 0x5678;
    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000

    // 字节转换到更小的类型时，丢失右侧数据。
    // bytes4 => bytes2
    bytes4 public b1 = 0x12345678;
    bytes2 public b2 = bytes2(b1); // b2 = 0x1234
}
```

**bytes 显式转换成更小的类型**

```solidity
bytes2 a = 0x1234;
bytes1 b = bytes1(a); // b 为 0x12
```

**bytes 显式转换成更大的类型**

```solidity
bytes2 a = 0x1234;
bytes4 b = bytes4(a); // b 为 0x12340000
```

### 8.2.3 bytes 与 uint 转换

只有当字节类型和整数类型大小相同时，才可以进行转换。

因为整数和定长字节数组在截断（或填充）时行为是不同的，如果要在不同的大小的整数和定长字节数组之间进行转换，**必须使用一个中间类型来明确进行所需截断和填充的规则**

```solidity
bytes2 a = 0x1234;
uint32 b = uint16(a);           // b 为 0x00001234
uint32 c = uint32(bytes4(a));   // c 为 0x12340000

uint8  d = uint8(uint16(a));    // d 为 0x34
uint8  e = uint8(bytes1(a));    // e 为 0x12
```

**1.bytes 转换成 uint**: **先转类型，再转大小**

- 推荐先把 bytes 显示转换成数字类型后，再转换成更大或更小的数字

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// - `uint8`  等于两位连续的十六进制数字 `0xXX`
// - `bytes1` 等于两位连续的十六进制数字 `0xXX`
// - `bytes1` 等于 `uint8`
contract Demo1 {
    // bytes => uint
    bytes2 public a1 = 0x5678; // : 十进制数字 = 22136
    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000 : 十进制数字 = 1450704896
    bytes1 public a3 = bytes1(a1); // a3 = 0x56 : 十进制数字 = 86

    // -- 增大
    // bytes 显示转换成数字后，显示转换更大的数字 (这里也可以隐式完成)
    uint32 public a4 = uint32(uint16(a1)); // ✅ a4 = 0x00005678 : 十进制 = 22136
    // bytes 显示转换成更大数字对应的的bytes，然后bytes显示转换成匹配的数字
    uint32 public a5 = uint32(bytes4(a1)); // ❌ a5 = 0x56780000 : 十进制 = 1450704896

    // -- 减小
    // bytes 显示转换成数字后，显示转换成更小的数字
    uint8 public a6 = uint8(uint16(a1)); // ✅ a6 = 0x78 : 十进制 = 120
    // bytes 显示转换成更小数字对应的的bytes，然后bytes显示转换成匹配的数字
    uint8 public a7 = uint8(bytes1(a1)); // ❌ a7 = 0x56 : 十进制 = 86
}
```

**2.uint 转换成 bytes**: **先转大小，再转类型**

- 推荐先把 uint 显示转换成更大 bytes 对应的 uint，然后 uint 再显示转换成匹配的 bytes

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo2 {
    // uint => bytes
    uint16 public b1 = 0x5678; // 0x5678 : 十进制 = 22136
    uint32 public b2 = uint32(b1); // b2 = 0x00005678 : 十进制 = 22136
    uint8 public b3 = uint8(b1); // b3 = 0x78 : 十进制 = 120
    // -- 增大
    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes
    bytes4 public b4 = bytes4(bytes2(b1)); // ❌ b4 = 0x56780000
    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes
    bytes4 public b5 = bytes4(uint32(b1)); //  ✅ b5 = 0x00005678

    // -- 减小
    // uint 显示转换成bytes类型后，再显示转换成更大或更小的bytes
    bytes1 public b6 = bytes1(bytes2(b1)); // ❌ b4 = 0x56
    // uint 显示转换成更大bytes对应的uint，然后uint再显示转换成匹配的bytes
    bytes1 public b7 = bytes1(uint8(b1)); // ✅ b4 = 0x78
}
```

### 8.2.4 bytes 和 bytesN 之间转换

`bytes` 数组和 `bytes calldata` 切片可以显示转换为固定长度的 bytes 类型(`bytes1...bytes32`).

- 如果数组比固定长度的 bytes 类型长，则在末尾处会发生截断。
- 如果数组比目标类型短，它将在末尾用零填充。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    // 0x6162636465666768
    bytes public bts = "abcdefgh";
    bytes3 public b1 = bytes3(bts);
    bytes8 public b2 = bytes8(bts);
    bytes16 public b3 = bytes16(bts);
    bytes32 public b4 = bytes32(bts);
}
```

**补充**：使用切片也可以把数据从 bytes 转为 bytesN。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    // 0x6162636465666768
    bytes public bts = "abcdefgh";

    function f(bytes calldata bts_)
        public
        pure
        returns (bytes3,bytes16)
    {

        bytes3 b1 = bytes3(bts_);
        bytes16 b2 = bytes16(bts_[:8]);
        return (b1, b2);
    }
}
```

### 8.2.5 bytes 与 address 转换

address 的格式是 `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`，是一个 **bytes20** 的数据。

地址是取 `bytes32` 数据中的后 20 位。如果想删除前面的 12 位数据，可以使用 solidity assembly (内联汇编) 来截取，也可以借助 `uint` 转换成更小的类型，会丢失左侧数据的特性来完成。

代码如下:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // 获取即将部署的地址
    function getAddress(bytes memory bytecode, uint256 _salt)
        external
        view
        returns (address)
    {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff), // 固定字符串
                address(this), // 当前工厂合约地址
                _salt, // salt
                keccak256(bytecode) //部署合约的 bytecode
            )
        );
        // bytes 转换成 uint: 先转类型，再转大小
        //      bytes32 => uint256 => uint160
        // uint160 转 address
        //      uint160 => address
        return address(uint160(uint256(hash)));
    }
}
```

前文介绍过编码的方式: `keccak256(abi.encodePacked())`，返回的是 `bytes32` 类型。

这个小例子是**合约部署合约**那章节中 create2 代码的一部分，相关的更多演示请查看 create2 创建。

## 8.3 数字转换成字符串

### 8.3.1 直接借助 bytes 和 string（未完成）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // `固定大小字节数组` —> `动态大小字节数组` —> `string`
    function test(uint8 num_) public pure returns (bytes1 ab,string memory data) {
        // 固定大小字节数组
        ab = bytes1(num_);

        // `固定大小字节数组` —> `动态大小字节数组`
        bytes memory temp = new bytes(ab.length); // 可变字节数组创建方式
        for (uint8 i = 0; i < ab.length; i++) {
            temp[i] = ab[i];
        }

        // `动态大小字节数组` —> `string`
        data = string(temp);
    }
}
```

### 8.3.2 借助单个数字转换（推荐）

这种方法是借助将 0-9 的数字进行转换，然后超过十位的数字，通过 `%` 来得到，并且拼接在一起。
推荐方法：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function uintToString(uint256 _uint)
        public
        pure
        returns (string memory str)
    {
        if (_uint == 0) return "0";
        while (_uint != 0) {
            //取模
            uint256 remainder = _uint % 10;
            //每取一位就移动一位，个位、十位、百位、千位……
            _uint = _uint / 10;
            //将字符拼接，注意字符位置
            str =  string.concat(toStr(remainder), str);
        }
    }

    function toStr(uint256 num_) internal pure returns (string memory) {
        require(num_ < 10,"error");
        bytes memory alphabet = "0123456789";
        bytes memory str = new bytes(1);
        str[0] = alphabet[num_];
        return string(str);
    }
}
```

