---
title: Solidity

date: 2022-12-14	

categories: 区块链知识	

tags: [区块链,区块链知识]
---	

# solidity上如何在数组删除一个数

根据下标用delete使其变为默认值，如果是动态数组可以通过pop方法移除该数组不过需要与最后一个位置的元素交换

# 你是如何用以太坊实现资金托管的

function用payable修饰，然后可以对合约账户balance

低级CALL调用**不需要`payable address`**,transfer 和 send **只能是 `payable address`**

transfer()错误会回滚，send会返回一个bool，call也是返回bool和返回数据bytes memory

call的 gas 可以动态调整,transfer 和 send 只能是固定制 `2300`

# 如何对一个数组去重

用一个map检查数组元素有无出现，无出现就装进res

双重循环

还有其他实现吗(使用 Solidity 的 Set 数据结构进行去重，一个库）

跟最后一个元素互换然后pop / 直接delete

# solidity的function的可见性

- 函数有四可见型，分别是 `private` / `external` / `internal` / `public`
- 状态变量可以有三种可见型，分别是 `private` / `internal` / `public`

1. **private**: 私有，仅在当前合约中可以访问，在继承的合约内不可访问

2. **internal(默认)**: 能在它们所定义的合约和派生合同中访问,它们不能被外部访问

   > 需要注意的是不能加前缀 this，前缀 this 是表示通过外部方式访问

3. **external:** 只能从智能合约外部调用。 如果要从智能合约中调用它，则必须使用this

4. **public**: 公开可视(合约内部，被继承的，外部都可以调用)

# 合约发布的数据结构

合约发布的数据结构主要包括状态变量和函数：

状态变量（State Variables）：状态变量是在合约中声明的变量，存储在区块链上。

函数（Functions）：合约中的函数定义了合约的行为和操作。函数可以接受参数、返回值，并且可以修改合约的状态（通过修改状态变量）。

# solidity函数修饰器

可以将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。

作用: 常用于在函数执行前检查某种前置条件。

- 比如地址对不对，余额是否充足，参数值是否允许等
- 修改器内可以写逻辑

如果同一个函数有多个修改器 modifier，它们之间以空格隔开，修改器 modifier 会依次检查执行。

**修改器不能隐式地访问或改变它们所修饰的函数的参数和返回值。** 这些值只能在调用时明确地以参数传递。

`_` 符号可以在修改器中出现多次，每处都会替换为函数体。

# Solc编译器的原理、汇编过程

Solc是Solidity编译器，它的主要功能是将Solidity源代码编译成EVM字节码

1. 原理：**Solc编译器会先对Solidity源代码进行词法分析和语法分析，生成抽象语法树（AST）。然后，Solc编译器会将AST转换为中间语言（IR），并进行优化和分析。最后，Solc编译器会将IR转换为EVM字节码，并输出编译结果。**

2. 汇编过程

   （1）将Solidity源代码转换为中间语言（IR）。

   （2）对IR进行优化和分析，包括常量折叠、死代码删除、控制流图重构等操作。

   （3）将IR转换为EVM汇编代码，包括指令选择、寄存器分配、代码生成等操作。

   （4）将EVM汇编代码转换为二进制字节码。

   在上述过程中，Solc编译器使用了多种技术和算法，包括词法分析、语法分析、AST转换、中间代码优化、寄存器分配、指令选择等。这些技术和算法的目的是提高编译器的性能和生成的字节码的质量，从而使Solidity合约在EVM上的执行更加高效和安全。

# 说一下合约的安全分析方法、原理

1. **静态分析：**静态分析是通过**检查源代码或字节码**来识别潜在的安全问题。它可以帮助**发现潜在的漏洞、错误和安全隐患**。静态分析工具**会检查代码中的常见安全问题，例如整数溢出、未经授权的访问、重入漏洞等，并给出相应的警告或错误信息。**
2. **污点分析：**污点分析是一种静态或动态分析技术，用于**追踪数据流中的敏感信息（称为污点）并检测潜在的漏洞**。在合约中，污点分析可用于**追踪用户输入数据（如交易输入、合约参数等）如何在代码中传播，并检测是否存在未经适当处理的污点数据访问或潜在的漏洞。**
3. **符号执行：**符号执行是一种静态分析技术，它通过**符号变量替代具体输入值**，以**遍历可能的执行路径并生成约束条件**。通过符号执行，可以**检测合约中的潜在漏洞，如条件分支错误、溢出漏洞等**。然而，由于符号执行的复杂性，它在实际中的应用受到一些限制。
4. **模糊测试：**模糊测试是一种动态测试技术，**通过生成大量的随机或半随机输入来评估系统的安全性**。在合约中，模糊测试可以**通过生成随机交易和参数等输入来模拟潜在的攻击情景，以便发现合约中的漏洞和异常行为。**
5. **形式验证：**形式验证是一种基于数学和逻辑推理的方法，用于**验证合约是否满足特定的安全属性或规范**。通过形式验证，可以**对合约的正确性进行严格的数学证明**，从而**排除特定类型的漏洞**。然而，**形式验证通常需要高度专业的知识和复杂的建模过程，因此在实践中的应用相对较少。**
6. **动态分析：**动态分析是**在实际运行合约时监测和分析其行为**。通过**模拟不同的输入和交互场景**，可以发现潜在的漏洞和异常情况。动态分析可以**帮助检测运行时的安全问题，例如重入攻击、溢出等**。

# 合约内部调用和外部调用

内部：合约内部调用是指**在同一个合约内部调用另一个函数**，可以直接使用函数名进行调用，无需指定地址，**可以访问所有的状态变量和函数。**

外部：合约外部调用是指**在一个合约中调用另一个合约的函数**。在合约外部调用时，**需要指定被调用合约的地址，并使用`call`、`delegatecall`或`staticcall`等函数进行调用**。在合约外部调用时，**只能访问公共状态变量和函数。**

# 内部函数和外部函数区别

1. 访问权限：**内部函数可以被当前合约以及继承自当前合约的合约访问**，包括私有（private）和内部（internal）函数。而**外部函数只能被其他合约或外部账户通过消息调用的方式访问，通过合约地址和函数签名来执行外部调用。**
2. 调用开销：**内部函数的调用不涉及 EVM 的上下文切换和消息传递**，因为调用发生在同一个合约内部，没有跨合约的开销。而**外部函数的调用涉及 EVM 的上下文切换和消息传递，需要通过消息调用（message call）机制执行，因此具有更高的调用开销。**
3. 函数可见性修饰符：为了明确指定函数的可见性，**内部函数使用 `internal` 修饰符进行声明，而外部函数使用 `external` 修饰符进行声明。**

# Solidity引用类型storage、memory、calldata

`storage`是指**永久存储在区块链上的数据位置**，用于**存储合约状态变量**和映射类型的值。

`memory`是指**临时存储在计算机内存中的数据位置**，用于**存储函数局部变量和函数参数**。在函数内部声明的变量默认情况下会使用`memory`数据位置，`memory` 中的数据只在函数执行期间存在，并在函数执行结束后被清除。**引用类型局部变量，要显式指定数据位置**。

`calldata`是指**用于保存函数参数和外部函数调用数据的特殊区域**，**包括函数参数和函数签名等信息**。在函数调用时，函数参数会被复制到`calldata`中，并传递给被调用函数。在函数内部访问函数参数时，默认情况下会使用`calldata`数据位置。`calldata` 是只读的。

按照函数参数:

- 内部函数参数: (包括返回参数)都存储在**memory（内存）**中。
- 外部函数参数: (不包括返回参数)存储在 `calldata` 中。

# 数据赋值时何时进行值传递、何时进行引用传递

1. **在 storage 和 memory 之间两两赋值（或者从 calldata 赋值 ），值传递**。
2. 从 memory 到 memory 的两个引用赋值，引用传递。

# 说一下ERC20、ERC721的函数和作用、以及对应的缺点和改进的方案

 **标准 ERC20 接口**

3 个查询：

- `balanceOf`: 查询指定地址的 Token 数量
- `totalSupply`: 查询当前合约的 Token 总量
- `allowance`: 查询指定地址对另外一个地址的剩余授权额度

2 个交易：

- `transfer`: 从当前调用者地址发送指定数量的 Token 到指定地址,这是一个写入方法，所以还会抛出一个 `Transfer` 事件。
- `transferFrom`: 当向另外一个合约地址存款时，对方合约必须调用 transferFrom 才可以把 Token 拿到它自己的合约中。

1 个授权：`approve`: 授权指定地址可以操作调用者的最大 Token 数量。

缺点：ERC20标准**没有考虑到代币的独特性，所有代币都是同质化的，无法区分不同的代币。**

改进方案：**ERC1155标准是一种新的代币标准，它支持多种类型的代币，并且可以在一个合约中管理多种代币。**

**标准 ERC721 接口**

4 个查询：

- `balanceOf`: 查询指定地址的 NFT数量
- `ownerOf`: 查询当前NFT 的所属地址
- `isApprovedForAll`: 查询一个地址是否是另一个地址的授权操作员
- `getApproved`:获取单个 NFT 的授权地址

2 个交易：

- `safeTransferFrom`: 从 `_from` 地址转移到 `_to` 地址。与 `transferFrom` 不同，`safeTransferFrom` 函数在转移代币时会进行安全性检查。它会检查接收方合约是否实现了 ERC721Receiver 接口，并调用接收方合约中的 `onERC721Received` 方法，旨在确保代币转移的目的地是一个合适的接收方，并且能够正确处理接收的代币。
- `transferFrom`:从 `_from` 地址转移到 `_to` 地址，但它并没有提供任何安全性检查机制。

2个授权：

- `approve`: 授权指定地址可以操作某个NFT
- `setApprovalForAll`：授权指定地址可以操作msg.sender地址下的所有NFT

缺点：ERC721标准的转账操作比较复杂，需要调用多个函数才能完成，而且转账过程中可能会出现错误，导致代币丢失。

改进方案：ERC998标准是一种新的代币标准，它支持代币的组合和嵌套，可以将多个代币组合成一个更复杂的代币，并且可以在一个合约中管理多种代币。这样可以简化转账操作，减少出错的可能性。

# 事件中加indexed属性的作用

indexed 数据会被记录到 `topics` 中，可以用于检索，主题（topic）让我们可以可以搜索事件，比如在为某些事件过滤一些区块，还可以按发起事件的合同地址来过滤事件。

# 映射能否被声明为memory类型、映射中的key能否为复杂类型、映射的key是keccak256哈希还是真实的值、映射能否作为返回值、映射能否嵌套

1. **映射不能被声明为 `memory` 类型**。`memory` 类型用于临时存储和操作函数内的数据，而映射（`mapping`）是一种存储在存储器（`storage`）中的数据结构，无法在 `memory` 中声明。
2. **映射的键（`key`）可以是复杂类型，包括结构体、枚举和数组等。**映射的键类型不仅限于基本数据类型，你可以使用复杂类型作为映射的键。
3. **映射的键存储它的 `keccak256` 哈希值**，从而便于查询实际的值。正因为如此，映射是没有长度的，也没有 `key 的集合`或 `value 的集合`的概念
4. **映射不能用于合约公有函数的参数或返回值，只允许作为状态变量或作为函数内的存储引用或作为库函数的参数。**
5. **映射可以进行嵌套**

# Solidity中receive函数、fallback函数

fallback 函数是调用合约没有的方法时候执行，同时也可以设置为允许接收网络主币。

receive 只负责接收主币,一个合约最多有一个 `receive` 函数，receive 函数类型必须是 `payable` 的，声明为 payable 之后，其所消耗的 gas 最大量就会被限定在 2300。

# Solidity中view函数、pure函数的作用和区别

pure: 既**不读取也不修改状态变量**，这种函数被称为**纯函数**

view: 读取状态变量，但是不修改状态变量，这种函数被称为**视图函数**，状态变量的 Getter 方法默认是 view 函数。

# Solidity中字符串和字节有什么不同（bytes元素的内存是紧密连续存放的，不是按照 32 个字节为一单元）

字节分为定长字节数组(值类型)和变长字节数组(引用类型)，字符串是引用类型

定长字节数组：length、下标访问元素

不定长字节数组：length、下标访问元素、concat 拼接、push添加单个字节、pop删除数组的最后一个元素、delete、x[start:end]:数组切片

字符串：无length属性、无下标访问元素、concat 拼接

字符串（string）是动态大小的UTF-8编码字符序列，而字节（bytes）是一个固定大小的字节数组。在存储时，字符串会占用一个指针，指向实际存储字符串内容的位置，而字节则直接存储其内容。

> 比较两个字符串
>
> - `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`
> - `keccak256(bytes(s1)) == keccak256(bytes(s2))`:更省 gas

# bytes和bytes32的应用场景和区别

bytes类型适用于处理动态长度的字节数组，比如存储可变长度的文本数据或二进制数据。

bytes32类型适用于处理固定长度的字节数组，比如存储哈希值、加密签名等固定长度的二进制数据。

bytes类型没有固定的长度限制，可以根据需要动态调整大小。可以进行拼接、截取、访问等操作。

bytes32类型具有固定的长度限制，长度为32字节（256位）。可以进行比较、运算等操作。

# Solidity中constant和immutable的作用和区别

gas 要低很多、赋值后不可以修改

constant常量不是储存在`storage` 上，所以函数内读取常量不算`view`，可以使用 pure

constant常量在编译时确定，支持的仅有**值类型（包括地址类型）/字符串/bytes**，不允许任何通过访问 storage，区块链数据（例如 `block.timestamp`,`address(this).balance` 或者 `block.number`）或执行数据（ `msg.value` 或`gasleft()` ）对其赋值，

immutable不可变量可以在构建时确定，`immutable`仅支持值类型

# Solidity中创建合约的两种方式的区别和应用场景

通过 `new` 创建合约 / `create`：在**创建合约时根据创建合约的地址和创建合约交易时的 `nonce` 来计算合约的地址**。

通过 `salt` 创建合约 / `create2`：指定了一个可选的 `salt` （一个 bytes32 值），它将**根据给定的 `salt`** ，**创建合约的字节码和构造函数参数**来计算创建合约的地址，不再使用 `nonce`。

Uniswap中利用create2创建交易对，然后通过交易对代币地址可以推测出交易对地址与之交互，确保每次实例化的合约地址都是唯一的

> salt 决定了合约地址，不能重复使用，除非之前 salt 生成的合约被销毁了。

# Solidity中的错误类型（Panic和Error）出现的场景和表示意义

1. Panic（紧急情况）：
   - 场景：Panic**在发生无法恢复的严重错误或异常情况时触发**，例如**数组越界、除零操作、无效的操作**等。这些错误通常表示**合约处于一个不可处理的状态，无法继续执行，需要立即停止。**
   - 表示意义：Panic表示了**一种严重的错误或异常情况，合约无法继续正常执行**。它的目的是提醒开发者和用户发生了不可恢复的错误，可能需要修复合约代码或采取其他措施来处理问题。
2. Error（错误）：
   - 场景：Error通常在**可处理的错误或异常情况下触发**，例如**输入验证失败、外部调用返回错误结果**等。这些错误通常可以**通过适当的错误处理逻辑进行处理或恢复，不会导致合约无法继续执行**。
   - 表示意义：Error表示了**一种可处理的错误或异常情况，合约可以通过适当的错误处理逻辑进行恢复**。它的目的是**提供一种错误处理机制，使合约能够适当地处理错误情况，继续执行或采取适当的措施。**

> Panic通常通过使用`revert()`、`require()`或`assert()`等函数来触发。这些函数会中止当前的合约执行并回滚状态改变。而Error可以通过自定义的错误处理逻辑或使用`try-catch`语句来捕获和处理

# Solidity中assert和require的区别和应用场景

- `require`：用于验证**前置条件，例如输入验证、边界检查和约束条件的断言。**返还剩余的燃气
- `assert`：用于**验证合约内部的不变量和内部错误，主要用于验证内部逻辑的正确性。**不返还剩余的燃气

# Solidity中transfer、send、call转账的区别

低级CALL调用**不需要`payable address`**,ransfer 和 send **只能是 `payable address`**

transfer()失败时抛出异常,send()失败时仅会返回false,不会终止执行（合约地址转账）

call的 gas 可以动态调整,transfer 和 send 只能是固定制 `2300`

call除了可以转账外，可以还可以调用不知道 ABI 的方法，还可以调用的时候转账

# Solidity中call、delegatecall、staticcall、callcode区别

为了与不知道 ABI 的合约进行交互，Solidity 提供了函数 `call`/`delegatecall`/`staticcall` 直接控制编码。它们都带有一个 `bytes memory` 参数和返回执行**成功状态**（bool）和**数据**（bytes memory）。

**三种方法都提供 `gas` 选项，而 `value` 选项仅 `call` 支持** 。

call()：被调用合约内部如果有状态变量修改，则会被修改

delegatecall()：`delegatecall` 只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。`delegatecall` 的目的是使用另一个合约中的库代码。(用于升级合约)

staticcall()：与 call 基本相同，但**如果被调用的函数以任何方式修改状态变量，都将回退**

callcode()：在Solidity v0.5.0版本中被废弃，用于在当前合约的上下文中调用另一个合约的函数，但**共享相同的存储空间。**

# Solidity中的隐式转换和显示转换、函数可见性类型转换

**隐式转换：值类型，源类型必须是目标类型的子集。**

例如，`uint8` 可以转换为 `uint16`/`uint24`../`uint256`，因为`uint8`是`uint16`这些类型的子集。

但是 `int8` 不可以转换为 `uint256`，因为 `int8` 可以包含 `uint256` 中不允许的负值，比如 `-1`。

**显示转换：使用类型关键字，显式地将数据类型转换为另一种类型**

整型加大数据位置是从左侧增加，减小数据位置也是从左侧移除；（**整型是右对齐**）

字节加大数据位置是从右侧增加，减小数据位置也是从右侧移除；（**字节是左对齐**）

只有当字节类型和整数类型大小相同时，才可以进行转换。

bytes 和 bytesN 之间转换左对齐

bytes 与 address 转换：地址是取 `bytes32` 数据中的后 20 位，address(uint160(uint256(bytes32)))

**pure转view、view转non-payable、payable转non-payable**

# Solidity中合约继承方式、继承多个合约的顺序写法、super关键字作用

使用 `is` 实现继承：子类可以访问父类的权限修饰符只有：`public/internal`，不能是 `external/private`。

传参：contract C is A("n"),B("v") {}   /     constructor(string memory _name) A(_name) {}

一个合约**同时继承 2 个合约时，这种情况叫多重继承**，多重继承中不允许出现相同的**函数名**、**事件名**、**修改器名**以及**状态变量名**等，使用逗号分隔它们，并按照从左到右的顺序进行继承。

`super`关键字作用：

- 在子合约中，可以使用`super`关键字来引用父合约的函数和状态。
- 通过`super`关键字，可以调用父合约中的同名函数，并且可以在子合约中访问父合约的状态变量。
- 使用`super`关键字可以实现在子合约中对父合约行为的扩展或覆盖。

# Solidity中函数重写规则

solidity 引入了 `abstract`, `virtual`, `override` 几个关键字，用于重写函数。**父合约标记为 `virtual`函数可以在继承合约里重写(overridden)以更改他们的行为**。重写的函数需要使用关键字 `override` 修饰。

对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。

 `nonpayable` 可以被 `view` 和`pure` 覆盖。 `view` 可以被 `pure` 覆盖。 `payable`是一个例外，不能更改为任何其他可变性。

基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 `abstract`(interface)

# Solidity中的接口是什么

接口需要有 interface 关键字，并且内部只需要有函数的声明，不用实现，用于调用，里面的函数都没有实现且都是external，可以被继承和重写，限制：不包含变量或状态

# Solidity中的库

library 是智能合约的精简版，像智能合约一样，位于区块链上，通过EVM的delegatecall实现调用，库无状态变量，不能继承其他合约，如果被继承传参是引用，参数标识为storage，库合约函数的可视范围通常为internal，可变性为pure

直接调用库合约方法：Math.max(_x, _y);

using...for... 使用库合约：

```solidity
using ArrayLib for uint256[];
uint256[] public arr = [10, 11, 12, 13, 14,...];
...
arr.find(15); // 直接使用
...
```

# 如何分析链上交易过程、如何借助区块浏览器查询信息

搜索栏中输入要查询的信息，如**交易哈希、地址或合约地址。**

显示您查询相关的信息，如**交易细节、区块高度、转账金额等。**

查看交易的**确认状态、合约代码、事件日志等其他相关信息。**

**查看交易的输入和输出**，以了解合约函数的调用、转账操作等。

**检查合约事件日志**，了解触发的事件和相关数据。

可以**查看合约的源代码、合约持有人、合约创建者等详细信息**。

**Tenderly：**

智能合约调试：逐步执行合约代码，查看变量值和调用栈跟踪，更容易地定位和解决合约中的 bug 和问题。

交易模拟和回放：测试合约的行为和效果。这对于验证合约在不同情况下的行为非常有用，并且可以帮助发现潜在的安全问题和错误。

监视和警报：跟踪合约的状态变化、事件触发和交易执行情况，设置自定义警报规则，及时接收关键事件的通知。

性能分析：分析智能合约的性能和瓶颈，识别潜在的效率问题，并提供优化建议。

团队协作和共享：允许多个开发人员共同使用和管理合约，并在开发过程中共享调试会话、测试结果和分析数据。

# ABI的编码方式、solidity内置的ABI相关函数

ABI编码方式取决于参数的类型,以下是一些常见的数据类型和对应的ABI编码方式：

- 布尔类型（bool）：布尔值 `true` 编码为 1，布尔值 `false` 编码为 0。
- 整数类型（uint、int）：整数类型按照固定长度进行编码，如 uint8 编码为一个字节（8 位），uint256 编码为 32 字节（256 位）。整数类型的值通过大端（big-endian）字节序进行编码。
- 地址类型（address）：地址类型编码为 20 字节，其中前面 12 个字节为 0，后面 20 个字节表示地址的真实值。
- 字符串类型（string）：字符串类型的ABI编码与动态大小的字节数组类似，也包含一个32个字节的偏移量和实际的字符串数据。
- 字节数组类型（bytes）：动态大小的字节数组的ABI编码分为两部分，第一部分是32个字节的偏移量，指示实际数据在字节数组中的位置；第二部分是实际的字节数组数据。
- 动态数组类型（uint[]、address[]、string[] 等）：动态数组类型首先编码一个固定长度的字节数组，其中包含数组元素的 ABI 编码。然后在编码的开头添加表示数组长度的 32 位整数。
- 结构体类型（struct）：结构体类型的编码方式将结构体的各个成员依次进行 ABI 编码，按顺序将编码后的值拼接在一起。

以上是一些常见数据类型的ABI编码方式，对于更复杂的数据类型，如映射（mapping）和函数类型（function），其ABI编码方式会更加复杂。

Solidity 内置的 ABI 相关函数：进行ABI编码和解码，使得在Solidity中**与其他合约进行交互更加简单和高效。**

- `abi.encode(...) returns (bytes)`：将函数参数编码为字节数组
- `abi.encodePacked(...) returns (bytes)`：类似于 `abi.encode()`，但是不会为编码的参数添加长度前缀，返回一个紧凑的字节数组。
- `abi.decode(bytes memory encodedData, (...)) returns (...)`: 对给定的数据进行 ABI 解码，而数据的类型在括号中第二个参数给出 。 例如: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
- `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)`： :用于将函数名称和参数编码为一个字节数组，包括函数选择器。它接受函数选择器和函数参数列表作为参数，并返回编码后的字节数组。
- `abi.encodeWithSignature(string signature, ...) returns (bytes)`：类似于 `abi.encodeWithSelector()`，但是使用函数的完整签名来生成函数选择器。等价于 `abi.encodeWithSelector(bytes4(keccak256(selector), ...)`
- `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: 使用 tuple 类型参数 ABI 编码调用 `functionPointer` 。执行完整的类型检查, 确保类型匹配函数签名。结果和 `abi.encodeWithSelector(functionPointer.selector, (...))` 一致。

# 用户发起交易的整个过程描述一下，包括交易的数据结构、交易的过程

1. RLP编码：首先，**将交易数据按照RLP编码规则进行序列化**。RLP编码会将交易的各个字段转换为字节流，并添加长度前缀以表示字段的长度。(节省空间)
2. 私钥签名：**使用发送者的私钥对RLP编码后的交易数据进行签名**。这个过程使用**椭圆曲线数字签名算法**（ECDSA），通过将交易哈希与私钥进行加密生成数字签名。
3. 广播交易：**将签名后的交易广播到区块链网络中的节点。**
4. 进入交易池：**广播的交易首先进入待处理的交易池中。**交易池是存储待处理交易的缓冲区。**节点将验证交易的签名和有效性，**确保交易满足一些基本的规则和约束条件。
5. 排序：在交易池中，**交易会按照一定的规则进行排序**。常见的排序规则包括**按照交易的优先级、交易费用等进行排序。**
6. 打包进区块：**矿工节点从交易池中选择一些交易，并将它们打包进一个新的区块中。**矿工会将交易进行有效性验证，并根据交易费用的高低选择收入最高的交易。
7. 广播上链：一旦区块被**矿工节点打包完成，它会广播到网络中的其他节点。**其他节点会验证该区块的有效性，并将其添加到自己的本地副本中。

所提交的交易包括下列信息：

- `recipient` – 接收地址
- `signature` – 发送者的标识符。 当通过发送者的私钥签名交易来确保发送者已授权此交易时，生成此签名。
- `nonce` - 一个连续的递增计数器，表示帐户中的交易编号。
- `value` – 发送人向接收人转移的以太币金额（以以太币的一种面值 WEI 为单位）
- `data` – 可包括任意数据的可选字段
- `gasLimit` – 交易可以消耗的最大数量的燃料单位。 燃料单位代表计算步骤
- `maxPriorityFeePerGas` - 作为验证者小费包含的最大燃料数量
- `maxFeePerGas` - 愿意为交易支付的最大燃料数量

# 函数选择器的生成方式、组成、作用、为什么只取前4字节、以及在合约执行中的作用

函数选择器（Function Selector）是在以太坊智能合约中用于**标识函数的唯一标识符**。它由**函数的签名生成，并且通常只取前4个字节。**

**生成方式：**将函数的名称和参数类型按照特定规则进行编码，使用Keccak-256哈希算法（也称为SHA3-256）对编码后的数据进行哈希计算，从哈希结果中取前4个字节作为函数选择器。

**作用：**唯一标识函数、优化函数调用 (由于函数选择器只取前4个字节，因此可以减少传输的数据量，提高交易的效率。)

**在合约执行中的作用**:确定要执行的函数,确保在合约中正确地执行所需的操作。

# 详细说一下基于栈的虚拟机EVM（256位）、其上下文有哪些、存储空间有哪几类（stack、memory、storage）、stack的深度、访问的最大深度

EVM使用了基于栈的执行模型，其中包含以下几个关键组件：

1. 栈（Stack）：EVM**使用一个栈来存储和处理数据**。栈是一种**后进先出的数据结构**，用于**保存操作数、中间结果和返回值等**。
2. 存储器（Memory）：EVM提供了**一个字节数组作为存储器**，用于**临时存储合约执行过程中的数据**。存储器可以**通过索引访问，并且可以动态扩展。**
3. 存储（Storage）：EVM提供了**一个持久化的键值存储**，用于**在合约之间共享数据。存储是永久性的，即使合约执行结束后仍然保留。**
4. 指令集（Instruction Set）：EVM**定义了一套指令集，用于执行各种操作**，如算术运算、逻辑运算、内存访问、存储访问等。每个指令都有特定的操作码和操作数。
5. 状态转换（State Transition）：EVM**通过执行指令来改变合约的状态。每个指令都会消耗一定的气体（Gas）**，而气体是以太坊中的计价单位，用于限制合约执行的资源消耗。

EVM的设计目标是实现安全、确定性和可验证性。它提供了一个隔离的执行环境，**确保合约的执行结果在不同节点上是一致的**，并且可以通过区块链上的交易历史进行验证。

> 栈的最大深度为1024个元素,每层 32 字节,当栈的深度达到1024时，进一步的栈操作将会导致栈溢出错误（Stack Overflow Error）并终止合约的执行。

# 详细说一下EVM的“stack too deep”错误

EVM栈最多 1024 层，每层 32 字节， **对EVM栈的访问并不是完全严格按照先进后出，允许将顶端的 16 个元素中的某一个复制或者交换到栈顶**。每次操作**只能取栈顶的若干元素，把结果压栈**。也能够把**栈顶元素放到 memory 或者 storage 区域保存**。**因此一个函数最多16个变量。**

# 从EVM的角度阐述交易发送和调用合约的整个过程

- **交易创建：**用户通过以太坊钱包或其他工具**创建一笔交易**。交易包括发送者地址、接收者地址、数额以及其他必要的信息。交易被**广播到以太坊网络中。**
- **交易验证：**矿工节点在收到交易后，首先会**对交易进行验证**。验证包括检查交易的签名是否有效、发送者账户是否有足够的余额支付燃气费用等。
- **燃气消耗评估：**在验证通过后，矿工节点会评估交易执行所需的燃气消耗。每个操作码都有对应的燃气消耗，矿工节点会根据交易中的操作码和参数来计算燃气消耗。
- **合约创建/调用：**如果**交易的接收者地址是一个合约地址，则是对合约的调用。如果接收者地址是空，则是合约的创建。**对于合约的调用，矿工节点会**加载合约的字节码和状态，并按照交易中指定的函数和参数执行合约代码。**对于合约的创建，矿工节点会在以太坊网络上创建新的合约账户，并**将合约的字节码存储到账户的代码字段**。
- **状态变更：**在执行合约的过程中，**EVM会根据合约的代码逻辑和数据操作来进行状态变更。**这包括更新合约的存储（Storage）和内存（Memory），修改账户余额，创建新的合约账户等。**状态变更会被记录在内存中**，但**尚未写入区块链**。
- **状态回滚：**如果**合约执行过程中发生错误或抛出异常，EVM会回滚之前的状态变更，恢复到执行前的状态。**
- **交易广播：**如果交易通过了所有验证，并且燃气消耗检查也通过，**矿工节点将把交易添加到待处理交易池中**，等待被打包进区块。

# 以太坊的字节码、操作码是什么、如何进行单步调试、观察栈、内存的变化

字节码是一种低级的**指令集**，用于在以太坊虚拟机（EVM）上执行智能合约。操作码是字节码中的**具体指令**，用于执行各种操作，例如算术运算、逻辑运算、内存访问等

Remix、Geth控制台、Tenderly....

# 合约中的数据在存储中的组织形式、内存布局

数据可以存储在两个地方：存储（storage）和内存（memory）。

1. 存储（Storage）：存储**是永久性的，用于持久化保存合约的状态数据**。存储使用键值对的形式进行组织，其中键是一个256位的整数，值可以是任意大小的字节串。存储的访问是昂贵的，每次读取或写入都会消耗燃气。存储的内容在区块链上永久保存，并且可以被其他合约或外部账户访问。
2. 内存（Memory）：内存**是临时性的，用于在合约执行期间存储临时数据**。内存的访问速度较快，但在合约执行结束后会被清空。内存的布局是线性的，从位置0开始，可以按需分配和释放。合约可以通过指定偏移量和长度来访问内存中的数据。

内存布局包括以下几个部分：

- 栈（Stack）：栈用于存储函数调用时的局部变量、函数参数和返回值等数据。栈以先进后出的方式管理数据。
- 活动区域（Active Area）：活动区域用于存储当前正在执行的函数的局部变量和临时变量等数据。
- 自由区域（Free Area）：自由区域是未被使用的内存空间，可以用于存储额外的临时数据。

# 哪些地方会收取交易费gas？

每个操作码都有一个固定的燃气成本，对存储区域的写入和读取操作都会消耗燃气

非cesop（constant external state operation）操作：cesop操作是指不修改合约状态的操作，如只读函数调用。这些操作不会产生燃气费用。

# 合约的内联汇编是什么、如何通过内联汇编操作数据

内联汇编是一种在**底层访问以太坊虚拟机的语言**，实现一些高级语言无法直接表达的功能。

通过 `assembly {}` 包裹代码

# 智能合约

智能合约是存储在区块链上的一段程序代码，智能合约无需信任，其有几个特点：自动执行、结果可预见、记录公开可审计、透明和不可篡改、去中心化等等