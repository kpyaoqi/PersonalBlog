---
title: 区块链

date: 2022-12-18	

categories: 区块链知识	

tags: [区块链,区块链知识]
---	

# 智能合约中如何解决随机数的问题

使用区块变量，常见方法是使用`block.timestamp` 和 `block.difficulty`

使用API：通过数字签名的方式来证明随机数是取自于某个随机数服务提供并且未被篡改过

Chainlink VRF：提供了一个链上去中心化的解决方案

# oracle预言机(oraclize,chainlink,TEE(SGX))

在区块链中，智能合约通常只能读取和修改区块链上的数据，而无法访问外部的数据源，Oracle预言机被引入到区块链中。Oracle预言机是一种中心化的服务，它可以从外部数据源获取数据，并将数据传递给智能合约。智能合约可以使用这些数据来执行相应的操作。

分类：

1. 中心化Oracle预言机：中心化的Oracle预言机是最简单的实现方式。它通常由一个中心化的服务提供商提供，可以从外部数据源获取数据并将数据传递给智能合约。这种实现方式具有简单、易用和高可用的特点，但也存在单点故障和安全性问题。
2. 分布式Oracle预言机：分布式的Oracle预言机采用多个服务提供商来提供数据。它的实现方式可以基于共识算法（如PoS、PoW等），或者基于多方计算（MPC）协议。这种实现方式可以提高可靠性和安全性，但也增加了复杂度和成本。
3. 去中心化Oracle预言机：去中心化的Oracle预言机是最安全的实现方式。它通常基于区块链技术实现，使用智能合约来管理Oracle预言机。数据由多个服务提供商提供，并经过验证后提交到智能合约中。这种实现方式具有高可靠性和高安全性的特点，但也存在复杂度高和成本高的问题。

# event,modifier的作用和用法

event：

​	作用：应用程序通过以太坊客户端的 RPC 接口订阅和监听这些事件，外部应用程序可以根据这些通知做出相应的响应或者记录区块链的日志，日志与合约的地址关联，并记录到区块链中

​	用法：event ，emit，indexed关键字表示该参数可以在Event日志中被索引

modifier：

​	作用: 将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。

​	用法：常用于在函数执行前检查某种前置条件。

# solidity 各大版本的新特性

Solidity 0.7.0:

- 支持了 try/catch 异常处理
- 引入了 receive() 和 fallback() 函数，用于接收 Ether
- 引入了 contract 关键字，用于定义新的合约类型

Solidity 0.8.0:

- 引入了 calldata 关键字，用于指示函数参数应该在 calldata 中传递
- 支持了 struct 和 enum 的本地定义
- 支持了抽象合约（abstract contract）
- 函数参数可以标记为 immutable
- 引入了 error 关键字，用于定义错误类型

Solidity 0.9.0:

- 引入了 revert 可接受一个 string 参数
- 引入了内部可变映射（Internal Mutable Mapping）
- 引入了枚举元素间的数学操作符
- 引入了事件上的 gas 注释

# 形式化证明

形式化验证是指根据形式化规范评估系统正确性的过程。 简言之，形式化验证让我们可以检查系统的行为是否满足某些要求（即，系统按照我们的想法运作）

# contractfuzzer(模糊测试)有什么缺点

1. 覆盖率限制：模糊测试**通常只能测试少数路径，而不能测试所有路径**，因此存在漏洞被忽略的可能性。这可能导致合约中潜在的漏洞未被发现，从而导致安全风险。
2. 资源限制：使用模糊测试**需要耗费大量的计算资源和时间**，这可能会使得测试成本变得很高。特别是对于非常大的合约，测试过程可能需要数天或数周才能完成。
3. 精度问题：尽管模糊测试可以检测出许多常见的漏洞类型，但它可能**无法检测出复杂的漏洞**。例如，对于需要多步操作的漏洞，模糊测试可能无法完全模拟所有必要的操作序列。
4. 误报率高：模糊测试**可能会产生大量误报**，即将无害的代码标记为漏洞。这可能会导致开发人员在排查问题时浪费时间和精力。
5. 无法解决语义问题：模糊测试通常只能检查合约的语法正确性，而不能检查合约的**语义正确性**。这意味着即使合约代码通过了模糊测试，仍然可能存在潜在的逻辑问题

# 以太坊中nonce的作用(防止重放攻击)，如何获得nonce

nonce是一个递增的随机数，用于确保每笔交易是唯一的，并防止重放攻击。每个账户都有一个对应的nonce值，用于记录该账户已经发送了多少笔交易。当一个账户发送一笔交易时，交易的nonce值必须是该账户的当前nonce值加1，这样就确保了每笔交易的唯一性。

nonce值是公开可见的，可以通过区块浏览器等工具查询，或者web3.js、ethers.js

# 如何调用他人的合约：

通过接口方式调用

```solidity
interface AnimalEat {
    function eat() external returns (string memory);
}

contract Animal {
    function test(address _addr) external returns (string memory) {
        AnimalEat general = AnimalEat(_addr);
        return general.eat();
    }
}
```

通过签名方式调用：三个call

# 除开EVM，还知道什么虚拟机

1. Java虚拟机（JVM）：JVM是用于执行Java字节码的虚拟机，它是Java平台的核心组成部分之一。
2. NEO虚拟机（NeoVM）：NEO是一个开源的智能合约平台，它的虚拟机是NeoVM。
3. EOS虚拟机（EOS VM）：EOS是一个分散式应用平台，它使用的虚拟机是EOS VM。
3. 蚂蚁区块链虚拟机（AntChain VM）微众银行虚拟机（WeBank Chain VM）百度区块链虚拟机（XuperVM）万向区块链虚拟机（WASM VM）

区别：

1. 虚拟机类型：不同的区块链平台可能会使用不同类型的虚拟机，如**以太坊使用基于堆栈的EVM，NEO使用基于寄存器的NeoVM等等。**
2. 执行效率：不同的虚拟机在执行智能合约时，可能会有**不同的效率和速度，这取决于虚拟机的设计和实现。**
3. 编程语言支持：不同的虚拟机可能**支持不同的编程语言和智能合约开发框架**，例如以太坊支持Solidity、Vyper和Serpent等语言，NEO支持C#和Python等语言。
4. 安全性和可靠性：虚拟机在执行智能合约时需要确保安全和可靠，不同的虚拟机可能会**采用不同的安全机制和代码审核策略**，以确保智能合约的正确性和安全性。
5. **社区支持和生态系统**：不同的虚拟机可能有不同的社区支持和生态系统，这对于开发者和用户来说都非常重要，因为这意味着有更多的工具、文档和资源可供使用。

# Merkle树，MPT树如何构建，有何区别(这个经常问)

Merkle树和MPT（Merkle Patricia Trie）树都是一种**哈希树数据结构**，通常**用于验证数据的完整性和构建区块链系统中的状态树**

构建方式：

- Merkle树：Merkle树由叶子节点和父节点组成，叶子节点是数据块的哈希值，父节点是其两个子节点的哈希值的哈希值。构建Merkle树时，需要将所有数据块的哈希值按顺序排列成叶子节点，并对相邻的叶子节点进行哈希运算，得到它们的父节点。重复这个过程，直到得到根节点，也就是整棵树的哈希值。

- MPT树：健值对

  - 扩展节点（Extension Node）：只能有一个子节点。
  - 分支节点（Branch Node）：可以有多个节点。
  - 叶子节点（Leaf Node）：没有子节点。
  - 空节点：空字符串。

   ![image-20230412220424100](/noteimg/C:/Users/zhuba/Desktop/PersonalBlog/source/_posts/区块链/区块链知识/img/image-20230412220424100.png)

区别：

- 数据存储方式不同：**Merkle树是一种二叉树，每个叶节点存储的是数据的哈希值**，而非数据本身。MPT树是一种多叉树，每个节点存储的是**键值对**（Key-Value Pair），其中Key是数据的哈希值，而Value是数据本身。
- 数据更新方式不同：Merkle树是一种静态结构，一旦树构建完成，就**不能再添加或修改数据**。如果需要添加或修改数据，就需要重新构建整棵树。MPT树是一种动态结构，**可以动态地添加、修改、删除数据**。
- 查询方式不同：Merkle树**只能支持对整个数据块的完整性进行验证**，而不能支持对单个数据的验证和查询。MPT树可以**支持对单个数据的验证和查询**，因为每个节点存储的是Key-Value Pair，可以通过Key快速查找对应的Value。

# 以太坊是如何从POW转向POS的(Casper协议)

1. 引入Casper：Casper是一种基于权益证明的共识机制，节点被分为两种角色：**验证节点和提案节点。**验证节点验证区块和交易的有效性，并根据其权益大小来选择提案节点。提案节点负责创建新的区块并提交到链上。
2. 引入Beacon Chain：Beacon Chain是以太坊2.0版本的核心部分，是一个新的区块链，用于管理以太坊2.0中的验证器。验证器是指参与权益证明共识机制的节点，他们会投入自己的以太坊代币（ETH）来获得权益，然后运行验证器软件，对交易进行验证，并参与新块的生成。这两个区块链之间**通过分片技术进行交互**，共同组成了以太坊2.0的整体系统。
4. 以太坊2.0上线：在经过长时间的开发和测试后，以太坊2.0于2020年12月1日正式上线。

# 以太坊使用的密码学，对两者进行介绍

哈希函数Keccak-256：计算数据的摘要，以确保数据的完整性和一致性

椭圆曲线加密算法 ECDSA：生成公钥和私钥对，并使用这些密钥对来加密和签名交易数据

# 区块链怎么开启新的Epoch

区块链中的**Epoch是一个时间段，在该时间段内区块链网络采用相同的规则来验证和处理交易**。每个Epoch的长度和开始时间都可以由区块链协议的设计者来定义。一些区块链协议（如Ethereum）使用**基于区块高度的Epoch，而其他协议则使用基于时间的Epoch**。

要开启一个新的Epoch，需要满足以下条件：

1. 规定Epoch长度：首先，设计者需要规定一个新的Epoch的长度，这通常是一定的时间段（例如1个月），也可能是特定的区块高度。
2. 配置新的规则：设计者需要在新的Epoch开始之前确定新的规则，并将这些规则编码到区块链协议中。
3. 更新协议版本：如果新的Epoch需要更新协议版本，则需要将新版本的协议发布到网络中。在新的Epoch开始之前，节点需要升级到新版本的协议，以确保能够正确地验证和处理交易。
4. 触发新的Epoch：当达到新的Epoch的开始时间或区块高度时，节点将开始采用新的规则。新的Epoch的开始可能需要一些时间，以便所有节点都可以升级到新的协议版本并开始使用新的规则。

需要注意的是，开启新的Epoch需要区块链网络中的大多数节点都同意并接受新的规则。因此，设计者需要考虑到网络中各种参与者的需求和利益，以确保新的规则得到广泛的接受和采用。

# 每次fork block的时候具体算法是什么

1. 选择分支点：确定要创建新分支的区块链上的分支点。这个分支点通常是一个已经存在的区块，它将成为新分支的起点。
2. 创建新分支：创建一个新的区块链分支，该分支从分支点开始并包含一组新的交易和一个新的区块。
3. 确定新分支的长度：为了确定哪个分支是主链，需要确定每个分支的长度。这通常是通过比较每个分支的工作量来完成的。
4. 解决分支冲突：如果多个节点都创建了一个新的分支，则需要解决分支冲突。这通常是通过选择具有最长长度的分支来解决的。
5. 更新状态：一旦确定了主链，所有节点都将更新他们的状态，以反映新的交易和新的区块链状态。

# 智能合约

是**存储在区块链上的程序**，它是位于以太坊区块链上一个特定地址的一系列代码（函数）和数据（状态）。 它们**通常用于自动执行协议**，以便所有参与者都可以立即确定结果，而**无需任何中间人参与**，也不会浪费时间。 它们还可以自动完成工作流程，在满足条件时触发下一个操作。

# 区块链有哪些应用？

1. 去中心化：区块链是一种去中心化的技术，没有中央机构或单一实体来管理它。相反，它**由网络中的所有节点共同维护和管理**。
2. 不可篡改：区块链的数据是以区块的形式记录在链中，并且每个区块都包含前一个区块的哈希值。
3. 透明性：区块链是公开透明的，任何人都可以查看和验证交易记录。使得区块链非常适合需要公共透明度的领域，如金融和政府监（投票选举）
4. 安全性：由于区块链采用了加密技术来保护数据的完整性和安全性，因此它被认为是非常安全的技术。这使得区块链非常适合处理敏感数据和交易。
5. 智能合约：区块链技术还支持智能合约，这是一种自动执行的合约，其中条件和规则被编码到合约中。这使得合约的执行非常透明和可靠，因为它们完全基于代码和算法来执行。

DeFi，去中心化金融，利用区块链智能合约在链上完成资产兑换、借贷、杠杆、期货等交易。

数字艺术品/NFT：唯一性、稀缺性、可交易性，通过 NFT 可使从产生到交易都可追溯，版权的保护变得更加方便。

数字存证/防伪:数字身份认证确保身份信息的安全和隐私保护,技术可以被用于保护数字版权，以确保知识产权的安全和可追溯性

游戏:游戏数据不可篡改、玩家数据保护、虚拟物品拥有权等等的新型游戏方式

# 以太坊中有哪些树（交易树、收据树、状态树）

1. 状态树（State Tree）：以太坊中的状态树是一个Merkle树，用于存储整个以太坊网络中所有账户的状态信息，包括余额、智能合约代码、合约存储器中的数据等。
2. 交易树（Transaction Tree）：交易树是一个Merkle树，用于存储所有交易信息。每个区块中的交易都被添加到这个树中，并用于验证和确定区块的有效性。
3. 日志树（Receipt Tree）：日志树是一个Merkle树，用于存储交易执行后的日志信息。它包含了交易执行的结果、事件触发信息等。

# 为什么需要收据树

- 向轻节点提供Merkle Proof
- 更加复杂的查找查询，比如查询过去⼗天与某⼀智能合约有关的交易、过去⼗天的众筹事件等

# 以太坊里的状态是什么，状态树怎么存的状态

状态是指所有账户的集合状态，包括它们的余额、合约代码和存储在合约中的数据

每个账户都有一个唯一的地址（20个字节），它被用作状态树中叶子节点的键。

# 以太坊的合约数据的储存形式

(还是MPT。合约账户中的storage root，对应账户的storage trie)

# 比特币里的交易是怎么存的

（Merkle Tree，MT）

# 介绍Merkle Tree的性质、优点，为什么用Merkle Tree存

实现SPV、Merkle Proof

SPV是一种轻量级的验证方式，允许用户验证自己的交易和区块链数据，而无需下载和存储整个区块链的全部数据。相比于完整节点（Full Node），SPV节点只需保存区块头（block header）和一部分交易信息，可以通过少量的数据获取和验证自己的交易。

# 为什么以太坊要将MT改成MPT

- 数据存储方式不同：**Merkle树是一种二叉树，每个叶节点存储的是数据的哈希值**，而非数据本身。MPT树是一种多叉树，每个节点存储的是**键值对**（Key-Value Pair），其中Key是数据的哈希值，而Value是数据本身。
- 数据更新方式不同：Merkle树是一种静态结构，一旦树构建完成，就**不能再添加或修改数据**。如果需要添加或修改数据，就需要重新构建整棵树。MPT树是一种动态结构，**可以动态地添加、修改、删除数据**。
- 查询方式不同：Merkle树**只能支持对整个数据块的完整性进行验证**，而不能支持对单个数据的验证和查询。MPT树可以**支持对单个数据的验证和查询**，因为每个节点存储的是Key-Value Pair，可以通过Key快速查找对应的Value。

# 介绍比特币的UTXO

UTXO代表"Unspent Transaction Output"，即未花费的交易输出。UTXO模型是比特币使用的一种账户模型，与传统的账户余额模型不同。

每当一个比特币交易发生时，输入和输出被创建。交易的输入引用之前交易的输出，而交易的输出定义了新的UTXO。

# 比特币查询余额只能从头开始遍历整条链吗，有没有高效方法

1. 索引和数据库优化：区块链浏览器和钱包服务可以使用索引和数据库优化技术来加快查询速度。通过构建针对地址和UTXO的索引，可以快速定位相关的交易和UTXO，而不需要遍历整个区块链。
2. UTXO集合缓存：一些服务会在内存中维护一个UTXO集合的缓存，以提供快速的查询响应。这些缓存通常存储最近使用频繁的UTXO，使得查询余额时无需每次都遍历整个区块链。

# 比特币地址是怎么生成的

（助记词 <-> seed -> 私钥 -> 公钥 -> PubKeyHash <-> address, 其中<->表可双向转换，->表单向转换，最后的PubKeyHash转换为address的时候用的是base58编码，base58编码的原理即辗转相除法）

# 介绍Bloom filter特点

常数时间内判断一个元素是否可能属于一个集合、位数组相对于存储实际元素的集合所需的内存要小得多有一定的错误率、插入元素只需要对位数组进行哈希操作并设置相应的位删除操作在传统的Bloom filter中是不支持的、可调的错误率错误率取决于位数组的大小和哈希函数的个数

# 以太坊智能合约如何执行，介绍EVM底层

编译为字节码文件 --> 支付gas部署合约 --> 发起交易与合约交互 --> 交易上链后EVM执行合约字节码 --> 合约状态更新 --> 结果返回

# 以太坊相比于比特币的创新点

1. 智能合约：以太坊引入了智能合约的概念，使得开发者可以在区块链上编写和执行具有逻辑和功能的可编程合约。智能合约允许在区块链上进行复杂的业务逻辑，从简单的转账到复杂的去中心化应用（DApp）。
2. 图灵完备性：与比特币的脚本语言相比，以太坊的智能合约语言Solidity是图灵完备的，这意味着它可以进行更复杂的计算和逻辑运算。这为开发者提供了更大的灵活性和创新空间。
3. 共识算法：pos节省能源

# geth中的block、transction、log、receipt数据结构

# HP编码、RLP编码

HP编码主要用于数据压缩和编码方面，通过减少编码长度来节省存储空间和传输带宽。

RLP编码则更适用于序列化和反序列化数据，特别是在以太坊中作为一种通用的数据编码方式，用于存储和传输合约数据、交易数据等。

# 最长链原则

最长链定义：最长链是指具有最多区块的链，其中每个区块都是经过验证且有效的。

# 从架构设计层面说一下以太坊的各个层的作用

1. 基础设施层（Infrastructure Layer）： 基础设施层是以太坊的底层基础设施，包括**网络协议、点对点通信、数据同步和共识算法**等。这一层负责提供以太坊网络的运行环境和支持，确保节点之间的连接和通信，以及确保区块链的一致性和安全性。
2. 合约层（Contract Layer）： 合约层是以太坊的智能合约执行层，它**负责处理智能合约的执行和交互**。合约层包括以太坊虚拟机（EVM）和智能合约的执行环境。EVM 是一个隔离且安全的虚拟机环境，负责解释和执行智能合约的字节码。它提供了一组指令集和状态操作，使得智能合约可以在安全的环境中执行。
3. 表现层（Presentation Layer）： 表现层是以太坊的用户界面层，它提供了用户与以太坊网络进行交互的界面。这包括**钱包应用、区块浏览器、交易界面**等。表现层为用户提供了友好的界面和功能，使他们能够方便地管理钱包、查看交易和与智能合约进行交互。
4. 应用层（Application Layer）： 应用层是以太坊的最上层，包括去中心化应用（DApp）和智能合约的具体应用场景。在这一层，开发者可以基于智能合约构建各种应用，如**去中心化金融（DeFi）、数字身份、供应链管理**等。应用层利用以太坊提供的智能合约和区块链功能来实现特定的业务逻辑和功能，为用户提供创新和去中心化的应用体验。

# 如何理解Ai与web3之间的关系

**AI更多是生产力的发展，Web3则是生产关系的重新定义** 

**AI作为一种技术工具，可以在许多领域提高生产效率和效益。通过机器学习和深度学习等技术，AI能够处理大量的数据、自动化任务和决策过程**，从而减少人力资源的需求，提高工作效率。例如，在制造业中，AI可以用于优化生产流程、预测设备故障、提高产品质量等方面，从而提高整体生产力。

另一方面，**Web3代表了一种新的互联网模式，强调去中心化、自治和用户主权**。它基于区块链和智能合约等技术，重新定义了生产关系和价值交换方式。在传统的Web2模式中，平台拥有者掌握着用户数据和利益分配的权力，**而Web3则通过去中心化的方式，使用户能够更直接地参与到价值创造和分享中。这种重新定义的生产关系可以促进更公平、透明和可持续的经济模式。**
