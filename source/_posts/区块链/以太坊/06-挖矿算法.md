---
title: 06-挖矿算法

date: 2022-09-30	

categories: 以太坊	

tags: [区块链,以太坊]
---	

# LiteCoin(莱特币)

ASIC Resistance(抗拒ASIC专用矿机)：ASIC芯片相对普通计算机来说，算力强但访问内存性能差距不大，因此常用的方法为Memory Hard Mining Puzzle，即增加对内存访问的需求。

> 莱特币曾一度成为市值仅次于比特币的第二大货币。其基本设计大体上和比特币一致，但针对挖矿进行了修改。莱特币的puzzle基于Scrypt。Scrypt为一个对内存性能要求较高的哈希函数，之前多用于计算机安全密码学领域。

### 莱特币挖矿算法基本思想

1.设置一个很大的数组，按照顺序填充伪随机数。

> 因为哈希函数的输出我们并不能提前预料，所以看上去就像是一大堆随机的数据，因此称其为“伪随机数”。

Seed为种子节点，通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希得到的。
可以看到，这样的数组中取值存在前后依赖关系

![image-20230106105059962](/noteimg/C:/Users/zhuba/Desktop/PersonalBlog/source/_posts/区块链/以太坊/img/image-20230106105059962.png) 

2.在需要求解Puzzle的时候，按照伪随机顺序，从数组中读取一些数，每次读取位置与前一个数相关。例如：第一次，从A位置读取其中数据，根据A中数据计算获得下一次读取位置B；第二次,从B位置读取其中数据，根据B中数据计算获得下一次读取位置C；

![image-20230106105248055](/noteimg/C:/Users/zhuba/Desktop/PersonalBlog/source/_posts/区块链/以太坊/img/image-20230106105248055.png) 

### 分析

如果数组足够大，对于挖矿矿工来说，必须保存该数组以便查询，否则每次不仅计算位置，还要根据Seed计算整个数组数据，才能查询到对应位置的数据。这对于矿工来说，计算复杂度大幅度上升。
当然，矿工可以选择只保存一部分数据，例如：只保存奇数位置数据，偶数位置需要时再根据前一个奇数位置数据计算即可，从而对内存空间大小减少了一半(计算复杂度提高一点，但内存减少一半)。

> 核心思想：不能仅仅进行运算，增加其对内存的访问，从而实现对ASIC芯片不友好。

### 问题

该方法对Puzzle验证并不是很友好。想要验证该Puzzle，也需要存储该数组，因此对于轻节点来说，并不友好(系统中绝大多数节点为轻节点)，因此，莱特币真正应用来说，数组大小不敢设置太大。例如：对于计算机而言，1G毫无压力，而对于手机APP来说，1G占据空间就过大了。所以，实际中，莱特币系统设计的数组大小仅仅128K大小。



# 以太坊

以太坊的理念与莱特币相同，都是Memory Hard Mining Puzzle，但具体设计上与莱特币不同。

### 以太坊挖矿算法基本思想

设计了两个数据集（以太坊中这两个数组大小并不固定，因为考虑到计算机内存不断增大，因此该两个数组需要定期增大)，一大一小。小的为16MB的cache，大的数据集为1G的dataset(DAG)。其关系为，1G的数据集是通过16MB数据集生成而来的。

> 为了便于进行验证，轻节点保存16MB的Cache进行验证即可，而矿工为了减少重复计算则需要存储1GB大小的大数据集。

1.16MB的小Cache通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希获得的。

2.大的数组中每个元素都是从小数组中按照伪随机顺序读取一些元素，方法同莱特币中相同。如第一次读取A位置数据，对当前哈希值更新迭代算出下一次读取位置B，再进行哈希值更新迭代计算出C位置元素。如此来回迭代读取256次，最终算出一个数作为DAG中第一个元素，如此类推，DAG中每个元素生成方式都依次类推。

![image-20230106105918282](/noteimg/C:/Users/zhuba/Desktop/PersonalBlog/source/_posts/区块链/以太坊/img/image-20230106105918282.png) 

### 分析

轻节点只保存小的cache，验证时进行计算即可。但对于挖矿来说，如果这样则大部分算力都花费在了通过Cache计算DAG上面，因此，其必须保存大的数组DAG以便于更快挖矿。

### 以太坊挖矿过程：

根据区块block header和其中的Nonce值计算一个初始哈希，根据其映射到某个初始位置A，读取A位置的数及其相邻的后一个位置A'上的数,根据该两个数进行运算，算得下一个位置B，读取B和B'位置上的数，依次类推，迭代读取64次，共读取128个数。
![image-20230106110057457](/noteimg/C:/Users/zhuba/Desktop/PersonalBlog/source/_posts/区块链/以太坊/img/image-20230106110057457.png) 
最后，计算出一个哈希值与挖矿难度目标阈值比较，若不符合就重新更换Nonce，重复以上操作直到最终计算哈希值符合难度要求或当前区块已经被挖出。

> 目前以太坊挖矿以GPU为主，可见其设计较为成功，当然，以太坊实现ASIC Resistance除了挖矿算法设计之外，还存在另外一个原因，即其预期从**工作量证明(POW)**转向**权益证明(POS)**

### 权益证明(POS: Proof of State)

按照所占权益投票进行共识达成，类似于股份制有限共识按照股份多少投票，权益证明不需要挖矿。但实际上，以太坊目前仍然是POW挖矿共识机制。在设计之初，以太坊开发者就设想要从POW转向POS，并为了防止有矿工不愿意转埋下了一颗“难度炸弹”。但截至目前，以太坊仍然基于POW共识机制。