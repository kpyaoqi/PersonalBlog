---
title: 1_数组

date: 2023-09-05	

categories: 初级算法	

tags: [算法练习笔记,初级算法]
---	

# 1.删除排序数组中的重复项

给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

#### 示例：

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

#### 思路：

定义一个index变量，循环数组判断是否与临近的元素相同，若相同则赋值给下标为index的位置，并index+1，切片分割nums[:index]

# 2.买卖股票的最佳时机

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。

#### 示例：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。

#### 思路：

定义一个profit变量存储利润，循环数组判断是否比临近的元素大，若大则profit累加这个差值

# 3.旋转数组

给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

#### 示例 ：

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

#### 思路：

1.新建一个arr数组，循环原数组，将值赋值给new[(i+k)&len(nums)],arr为结果

2.先反转全部数组，再反转前k个，最后在反转剩余的

# 4.存在重复元素

给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。

#### 思路：

先排序，然后循环判断临近是否相等

# 5.只出现一次的数字

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

#### 思路：

我们只需要把所有的数字都异或一遍，最终的结果就是我们要求的那个数字  **a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。**

# 6.两个数组的交集 II

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

#### 思路：

先对两个数组排序，定义两个指针一个index变量=0，for i < len(nums1) && j < len(nums2)，判断哪个数小，则那个指针++，若相等则nums[index]=nums[i],然后三个变量++，最后返回nums[:index]

# 7.加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

#### 示例：

digits = [1,2,3]
输出：[1,2,4]

#### 思路：

从数组最后一个元素循环，如果!=9，dig[i]+=1并返回dig，否则dig[i]=0，如果退出循环说明全是9，则append([]int{1}, digits...)

# 8.移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

#### 示例：

nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

#### 思路：

1.把非零往前移，然后index++，然后循环index到数组长度设为零

2.定义i表示前面为零的个数，循环数组，如果为零，i++,否则nums[j-i] = nums[j]，nums[j] = 0

# 9.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

### 示例：

输入：nums = [3,2,4], target = 6
输出：[1,2]

### 思路:

新建一个map[int]int,遍历nums数组，判断map中是否存在target-v，若存在，返回k和target-v在map中的位置，若不存在则将这个值为键存入map中值为在nums数组的位置

# 10.有效数独

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

### 示例：

board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false

### 思路：

创建三个row,col,bax:=make([] []bool,9)，循环到9，三个的第i为make([]bool,9),双层循环r，c到9，判断board[r] [c]!='.'，

赋值num:=board[r] [c]-'0'-byte(1)，判断 rowbuf[r] [num] || colbuf[r] [num] || boxbuf[r/3*3+c/3] [num]，返回false，

继续，赋值rowbuf[r] [num] = true，colbuf[c] [num] = true，boxbuf[r/3*3+c/3] [num] = true，最后返回true

## 11.旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

### 示例:

![image-20230517103825323](/noteimg/C:/Users/zhuba/Desktop/PersonalBlog/source/_posts/算法练习笔记/初级算法/img/image-20230517103825323.png) 

### 思路：

先对角线旋转，在根据竖直轴对称翻转