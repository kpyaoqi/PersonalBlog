---
title: 算法面经

date: 2023-10-08	

categories: 算法练习笔记	

tags: [算法练习笔记]
---	

### 口撕链表是否有环

给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。

### 堆排序、快速排序的时间复杂度以及分别适用什么场景

快排：时间复杂度：平均情况下为O(nlogn)，最坏情况下为O(n^2)，空间复杂度：O(logn)。快速排序在大多数情况下都表现出良好的性能，特别是对于大规模数据集。它是一种原地排序算法，需要额外的空间很少。

堆排：时间复杂度：始终为O(nlogn)，空间复杂度：O(1)。适用场景：堆排序适用于需要原地排序的情况，但相比于快速排序和归并排序，它的性能稍差。它对于大规模数据集的排序也相对较慢。

### 手撕快排

```go
// 采用分治的思想，算法首先选择最后一个元素作为基准，并将数组划分为两部分。然后，它通过比较元素与基准的大小，将小于等于基准的元素交换到前面，大于基准的元素交换到后面。最后，递归地对划分的两部分进行排序。
func QuickSort(arr []int, low, high int) {
    if low < high {
        pivot := partition(arr, low, high)
        QuickSort(arr, low, pivot-1)
        QuickSort(arr, pivot+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    //记录基准元素最后的位置
    i := low - 1
    for j := low; j < high; j++ {
        //将小于等于基准的元素交换到前面
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    //大于基准的元素交换到后面
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

### 二叉排序树

```go
func insert(root *TreeNode, val int) *TreeNode {
	if root == nil {
		return &TreeNode{Val: val}
	}
	if val < root.Val {
		root.Left = insert(root.Left, val)
	} else {
		root.Right = insert(root.Right, val)
	}
	return root
}
```

### 二叉排序平衡树

是一种特殊的二叉排序树，它在插入和删除节点时会自动进行平衡操作，以保持树的平衡性，平衡因子是指节点的左子树高度减去右子树高度的值，其取值范围为-1、0、1，当插入或删除节点导致某个节点的平衡因子超出范围时，需要通过旋转操作来调整树的结构，使得树重新达到平衡状态。

### 红黑树

红黑树的每个节点都被标记为红色或黑色，同时满足以下五个性质：

1. 每个节点要么是红色，要么是黑色。
2. 根节点是黑色。
3. 每个叶子节点（NIL节点，空节点）是黑色。
4. 如果一个节点是红色，则它的两个子节点都是黑色。
5. 对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。

这些性质保证了红黑树的关键特性：从根节点到任意叶子节点的最长路径不超过最短路径的两倍，因此红黑树是近似平衡的。

### 最小生成树（两个算法）

最小生成树（Minimum Spanning Tree，简称MST）是指在一个**连通无向图中，找到一棵包含所有顶点且边权值之和最小的树。**最小生成树常用于解决网络设计、电力传输、通信网络等问题。

常见的求解最小生成树的算法有Prim算法和Kruskal算法。

1. Prim算法：
   - 选择一个起始顶点，将其加入最小生成树中。
   - 从与最小生成树相邻的顶点中选择一个权值最小的边，将其加入最小生成树中。
   - 重复上述步骤，直到最小生成树包含所有顶点。
2. Kruskal算法：
   - 将图中的所有边按照权值从小到大排序。
   - 依次选择权值最小的边，如果该边的两个顶点不在同一个连通分量中，则将该边加入最小生成树中，并合并这两个连通分量。
   - 重复上述步骤，直到最小生成树包含所有顶点。

这两种算法都能够求解最小生成树，选择哪种算法取决于具体的应用场景和图的规模。

### Dijkstra算法

Dijkstra算法是一种用于求解单源最短路径的经典算法，它能够找到从起始顶点到图中所有其他顶点的最短路径。

以下是Dijkstra算法的基本步骤：

1. 创建一个距离数组dist[]，用于存储起始顶点到各个顶点的最短距离。初始时，将起始顶点的距离设为0，其他顶点的距离设为无穷大。
2. 创建一个集合visited[]，用于记录已经确定最短路径的顶点。
3. 重复以下步骤，直到visited[]包含所有顶点：
   - 从未访问的顶点中选择一个距离最小的顶点u，并将其加入visited[]中。
   - 对于顶点u的每个邻接顶点v，如果通过顶点u到达顶点v的路径比当前记录的最短路径更短，则更新dist[v]的值为新的最短路径长度。
4. 最终，dist[]数组中存储的就是起始顶点到图中所有其他顶点的最短路径长度。

Dijkstra算法的核心思想是通过不断选择距离最小的顶点来逐步确定最短路径，直到所有顶点都被确定。该算法适用于没有负权边的图。

需要注意的是，Dijkstra算法只能求解单源最短路径，即从一个起始顶点到其他所有顶点的最短路径。如果需要求解任意两个顶点之间的最短路径，则可以使用Floyd-Warshall算法或者Bellman-Ford算法。

### 100桶酒，其中一桶有毒，一只实验老鼠喝了酒之后一小时有结果，问一小时之内最少几只老鼠可以试出毒酒。

最少需要7只老鼠，100桶酒可以用7位二进制数表示（从0000000到1111111），7只老鼠编号，我们将每一只老鼠与二进制数的一位对应起来
